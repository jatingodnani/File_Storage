{"ast":null,"code":"import { EventEmitter } from './EventEmitter';\nimport { keys } from '@airgap/beacon-utils';\nimport { MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixClientEventType } from './models/MatrixClientEvent';\nexport class MatrixClientEventEmitter extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.eventEmitProviders = new Map([[MatrixClientEventType.INVITE, () => [this.isInvite, this.emitInvite.bind(this)]], [MatrixClientEventType.MESSAGE, () => [this.isMessage, this.emitMessage.bind(this)]]]);\n  }\n  /**\r\n   * This method is called every time the state is changed\r\n   *\r\n   * @param _oldState\r\n   * @param _newState\r\n   * @param stateChange\r\n   */\n  onStateChanged(_oldState, _newState, stateChange) {\n    for (const event of keys(MatrixClientEventType)) {\n      this.emitIfEvent(MatrixClientEventType[event], stateChange);\n    }\n  }\n  /**\r\n   * Emit the message if we have listeners registered for that type\r\n   *\r\n   * @param eventType\r\n   * @param object\r\n   */\n  emitIfEvent(eventType, object) {\n    const provider = this.eventEmitProviders.get(eventType);\n    if (provider) {\n      const [predicate, emitter] = provider();\n      if (predicate(object)) {\n        emitter(eventType, object);\n      }\n    }\n  }\n  /**\r\n   * Emit a client event\r\n   *\r\n   * @param eventType\r\n   * @param content\r\n   */\n  emitClientEvent(eventType, content, timestamp) {\n    this.emit(eventType, {\n      type: eventType,\n      content,\n      timestamp\n    });\n  }\n  /**\r\n   * Check if event is an invite\r\n   *\r\n   * @param stateChange\r\n   */\n  isInvite(stateChange) {\n    return stateChange.rooms ? stateChange.rooms.some(room => room.status === MatrixRoomStatus.INVITED) : false;\n  }\n  /**\r\n   * Emit an invite\r\n   *\r\n   * @param eventType\r\n   * @param stateChange\r\n   */\n  emitInvite(eventType, stateChange) {\n    stateChange.rooms.filter(room => room.status === MatrixRoomStatus.INVITED).map(room => [room.id, room.members]).forEach(_ref => {\n      let [id, members] = _ref;\n      this.emitClientEvent(eventType, {\n        roomId: id,\n        members: members\n      });\n    });\n  }\n  /**\r\n   * Check if event is a message\r\n   *\r\n   * @param stateChange\r\n   */\n  isMessage(stateChange) {\n    return stateChange.rooms ? stateChange.rooms.some(room => room.messages.length > 0) : false;\n  }\n  /**\r\n   * Emit an event to all rooms\r\n   *\r\n   * @param eventType\r\n   * @param stateChange\r\n   */\n  emitMessage(eventType, stateChange) {\n    stateChange.rooms.filter(room => room.messages.length > 0).map(room => room.messages.map(message => [room.id, message, message.timestamp])).reduce((flatten, toFlatten) => flatten.concat(toFlatten), []).forEach(_ref2 => {\n      let [roomId, message, timestamp] = _ref2;\n      this.emitClientEvent(eventType, {\n        roomId,\n        message\n      }, timestamp);\n    });\n  }\n}","map":{"version":3,"names":["EventEmitter","keys","MatrixRoomStatus","MatrixClientEventType","MatrixClientEventEmitter","constructor","eventEmitProviders","Map","INVITE","isInvite","emitInvite","bind","MESSAGE","isMessage","emitMessage","onStateChanged","_oldState","_newState","stateChange","event","emitIfEvent","eventType","object","provider","get","predicate","emitter","emitClientEvent","content","timestamp","emit","type","rooms","some","room","status","INVITED","filter","map","id","members","forEach","_ref","roomId","messages","length","message","reduce","flatten","toFlatten","concat","_ref2"],"sources":["../../../src/matrix-client/MatrixClientEventEmitter.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module"}