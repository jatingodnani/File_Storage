{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateKey = exports.openSecretBox = exports.secretBox = void 0;\nconst xsalsa20_1 = require(\"@stablelib/xsalsa20\");\nconst poly1305_1 = require(\"@stablelib/poly1305\");\nconst wipe_1 = require(\"@stablelib/wipe\");\nconst random_1 = require(\"@stablelib/random\");\nfunction secretBox(key, nonce, data) {\n  if (nonce.length !== 24) {\n    throw new Error(\"secretBox nonce must be 24 bytes\");\n  }\n  const firstBlock = new Uint8Array(64);\n  // Allocate place for nonce and counter.\n  const nonceCounter = new Uint8Array(24 + 8);\n  // Set first bytes to nonce. Last 8 bytes will be counter.\n  nonceCounter.set(nonce);\n  // Generate first block of XSalsa20 stream, of which\n  // first 32 bytes will be authentication key, and the rest\n  // will be used for encryption.\n  (0, xsalsa20_1.stream)(key, nonceCounter, firstBlock, 8);\n  // Allocate result, which will contain 16-byte authenticator\n  // concatenated with ciphertext.\n  const result = new Uint8Array(16 + data.length);\n  // Encrypt first 32 bytes of data with last 32 bytes of generated stream.\n  for (let i = 0; i < 32 && i < data.length; i++) {\n    result[16 + i] = data[i] ^ firstBlock[32 + i];\n  }\n  // Encrypt the rest of data.\n  if (data.length > 32) {\n    (0, xsalsa20_1.streamXOR)(key, nonceCounter, data.subarray(32), result.subarray(16 + 32), 8);\n  }\n  // Calculate Poly1305 authenticator of encrypted data using\n  // authentication key in the first block of XSalsa20 stream.\n  const auth = (0, poly1305_1.oneTimeAuth)(firstBlock.subarray(0, 32), result.subarray(16));\n  // Copy authenticator to the beginning of result.\n  for (let i = 0; i < auth.length; i++) {\n    result[i] = auth[i];\n  }\n  // Clean auth.\n  (0, wipe_1.wipe)(auth);\n  // Clean first block.\n  (0, wipe_1.wipe)(firstBlock);\n  // Clean nonceCounter.\n  (0, wipe_1.wipe)(nonceCounter);\n  return result;\n}\nexports.secretBox = secretBox;\nfunction openSecretBox(key, nonce, box) {\n  if (nonce.length !== 24) {\n    throw new Error(\"secretBox nonce must be 24 bytes\");\n  }\n  if (box.length < 16) {\n    throw new Error(\"secretBox data must be at least 16 bytes\");\n  }\n  const firstBlock = new Uint8Array(64);\n  // Allocate place for nonce and counter.\n  const nonceCounter = new Uint8Array(24 + 8);\n  // Set first bytes to nonce. Last 8 bytes will be counter.\n  nonceCounter.set(nonce);\n  // Generate first block of XSalsa20 stream, of which\n  // first 32 bytes will be authentication key, and the rest\n  // will be used for encryption.\n  (0, xsalsa20_1.stream)(key, nonceCounter, firstBlock, 8);\n  // Calculate Poly1305 authenticator of encrypted data using\n  // authentication key in the first block of XSalsa20 stream.\n  const auth = (0, poly1305_1.oneTimeAuth)(firstBlock.subarray(0, 32), box.subarray(16));\n  // Check authenticator.\n  if (!(0, poly1305_1.equal)(auth, box.subarray(0, 16))) {\n    // Authenticator is incorrect: ciphertext or authenticator\n    // was corrupted, maybe maliciously.\n    return null;\n  }\n  // Authenticator verifies, so we can decrypt ciphertext.\n  const ciphertext = box.subarray(16);\n  // Allocate result array.\n  const result = new Uint8Array(ciphertext.length);\n  // Decrypt first 32 bytes of box with last 32 bytes of generated stream.\n  for (let i = 0; i < 32 && i < ciphertext.length; i++) {\n    result[i] = ciphertext[i] ^ firstBlock[32 + i];\n  }\n  // Decrypt the rest of data.\n  if (ciphertext.length > 32) {\n    (0, xsalsa20_1.streamXOR)(key, nonceCounter, ciphertext.subarray(32), result.subarray(32), 8);\n  }\n  // Clean auth.\n  (0, wipe_1.wipe)(auth);\n  // Clean first block.\n  (0, wipe_1.wipe)(firstBlock);\n  // Clean nonceCounter.\n  (0, wipe_1.wipe)(nonceCounter);\n  return result;\n}\nexports.openSecretBox = openSecretBox;\n/** Generates a 32-byte random secret key.  */\nfunction generateKey(prng) {\n  return (0, random_1.randomBytes)(32, prng);\n}\nexports.generateKey = generateKey;","map":{"version":3,"names":["xsalsa20_1","require","poly1305_1","wipe_1","random_1","secretBox","key","nonce","data","length","Error","firstBlock","Uint8Array","nonceCounter","set","stream","result","i","streamXOR","subarray","auth","oneTimeAuth","wipe","exports","openSecretBox","box","equal","ciphertext","generateKey","prng","randomBytes"],"sources":["../secretbox.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script"}