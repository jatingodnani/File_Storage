{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { verify } from '@stablelib/ed25519';\nimport { hash } from '@stablelib/blake2b';\nimport blake from 'blakejs';\nimport bs58check from 'bs58check';\nimport elliptic from 'elliptic';\nimport toBuffer from 'typedarray-to-buffer';\nvar Prefix;\n(function (Prefix) {\n  Prefix[\"TZ1\"] = \"tz1\";\n  Prefix[\"TZ2\"] = \"tz2\";\n  Prefix[\"TZ3\"] = \"tz3\";\n  Prefix[\"TZ4\"] = \"tz4\";\n  Prefix[\"KT\"] = \"KT\";\n  Prefix[\"KT1\"] = \"KT1\";\n  Prefix[\"EDSK2\"] = \"edsk2\";\n  Prefix[\"SPSK\"] = \"spsk\";\n  Prefix[\"P2SK\"] = \"p2sk\";\n  Prefix[\"EDPK\"] = \"edpk\";\n  Prefix[\"SPPK\"] = \"sppk\";\n  Prefix[\"P2PK\"] = \"p2pk\";\n  Prefix[\"EDESK\"] = \"edesk\";\n  Prefix[\"SPESK\"] = \"spesk\";\n  Prefix[\"P2ESK\"] = \"p2esk\";\n  Prefix[\"EDSK\"] = \"edsk\";\n  Prefix[\"EDSIG\"] = \"edsig\";\n  Prefix[\"SPSIG\"] = \"spsig\";\n  Prefix[\"P2SIG\"] = \"p2sig\";\n  Prefix[\"SIG\"] = \"sig\";\n  Prefix[\"NET\"] = \"Net\";\n  Prefix[\"NCE\"] = \"nce\";\n  Prefix[\"B\"] = \"B\";\n  Prefix[\"O\"] = \"o\";\n  Prefix[\"LO\"] = \"Lo\";\n  Prefix[\"LLO\"] = \"LLo\";\n  Prefix[\"P\"] = \"P\";\n  Prefix[\"CO\"] = \"Co\";\n  Prefix[\"ID\"] = \"id\";\n  Prefix[\"EXPR\"] = \"expr\";\n  Prefix[\"TZ\"] = \"TZ\";\n  Prefix[\"VH\"] = \"vh\";\n  //rollups\n  Prefix[\"TXR1\"] = \"txr1\";\n  Prefix[\"TXI\"] = \"txi\";\n  Prefix[\"TXM\"] = \"txm\";\n  Prefix[\"TXC\"] = \"txc\";\n  Prefix[\"TXMR\"] = \"txmr\";\n  Prefix[\"TXRL\"] = \"txM\";\n  Prefix[\"TXW\"] = \"txw\";\n})(Prefix || (Prefix = {}));\nconst prefix = {\n  [Prefix.TZ1]: new Uint8Array([6, 161, 159]),\n  [Prefix.TZ2]: new Uint8Array([6, 161, 161]),\n  [Prefix.TZ3]: new Uint8Array([6, 161, 164]),\n  [Prefix.TZ4]: new Uint8Array([6, 161, 166]),\n  [Prefix.KT]: new Uint8Array([2, 90, 121]),\n  [Prefix.KT1]: new Uint8Array([2, 90, 121]),\n  [Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),\n  [Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),\n  [Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),\n  [Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),\n  [Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),\n  [Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),\n  [Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),\n  [Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),\n  [Prefix.SPESK]: new Uint8Array([0x09, 0xed, 0xf1, 0xae, 0x96]),\n  [Prefix.P2ESK]: new Uint8Array([0x09, 0x30, 0x39, 0x73, 0xab]),\n  [Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),\n  [Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),\n  [Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),\n  [Prefix.SIG]: new Uint8Array([4, 130, 43]),\n  [Prefix.NET]: new Uint8Array([87, 82, 0]),\n  [Prefix.NCE]: new Uint8Array([69, 220, 169]),\n  [Prefix.B]: new Uint8Array([1, 52]),\n  [Prefix.O]: new Uint8Array([5, 116]),\n  [Prefix.LO]: new Uint8Array([133, 233]),\n  [Prefix.LLO]: new Uint8Array([29, 159, 109]),\n  [Prefix.P]: new Uint8Array([2, 170]),\n  [Prefix.CO]: new Uint8Array([79, 179]),\n  [Prefix.ID]: new Uint8Array([153, 103]),\n  [Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),\n  // Legacy prefix\n  [Prefix.TZ]: new Uint8Array([2, 90, 121]),\n  [Prefix.VH]: new Uint8Array([1, 106, 242]),\n  [Prefix.TXR1]: new Uint8Array([1, 128, 120, 31]),\n  [Prefix.TXI]: new Uint8Array([79, 148, 196]),\n  [Prefix.TXM]: new Uint8Array([79, 149, 30]),\n  [Prefix.TXC]: new Uint8Array([79, 148, 17]),\n  [Prefix.TXMR]: new Uint8Array([18, 7, 206, 87]),\n  [Prefix.TXRL]: new Uint8Array([79, 146, 82]),\n  [Prefix.TXW]: new Uint8Array([79, 150, 72])\n};\nconst prefixLength = {\n  [Prefix.TZ1]: 20,\n  [Prefix.TZ2]: 20,\n  [Prefix.TZ3]: 20,\n  [Prefix.TZ4]: 20,\n  [Prefix.KT]: 20,\n  [Prefix.KT1]: 20,\n  [Prefix.EDPK]: 32,\n  [Prefix.SPPK]: 33,\n  [Prefix.P2PK]: 33,\n  [Prefix.EDSIG]: 64,\n  [Prefix.SPSIG]: 64,\n  [Prefix.P2SIG]: 64,\n  [Prefix.SIG]: 64,\n  [Prefix.NET]: 4,\n  [Prefix.B]: 32,\n  [Prefix.P]: 32,\n  [Prefix.O]: 32,\n  [Prefix.VH]: 32,\n  [Prefix.TXR1]: 20,\n  [Prefix.TXI]: 32,\n  [Prefix.TXM]: 32,\n  [Prefix.TXC]: 32,\n  [Prefix.TXMR]: 32,\n  [Prefix.TXRL]: 32,\n  [Prefix.TXW]: 32\n};\n\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid key being passed or used\r\n */\nclass InvalidKeyError extends Error {\n  constructor(key, errorDetail) {\n    super(`The key ${key} is invalid. ${errorDetail}`);\n    this.key = key;\n    this.errorDetail = errorDetail;\n    this.name = 'InvalidKeyError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an Invalid Public Key being passed or used\r\n */\nclass InvalidPublicKeyError extends Error {\n  constructor(publicKey, errorDetail) {\n    super(`The public key '${publicKey}' is invalid. ${errorDetail}`);\n    this.publicKey = publicKey;\n    this.name = 'InvalidPublicKeyError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid signature being passed or used\r\n */\nclass InvalidSignatureError extends Error {\n  constructor(signature, errorDetail) {\n    super(`The signature '${signature}' is invalid (${errorDetail})`);\n    this.signature = signature;\n    this.name = 'InvalidSignatureError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid message being passed or used\r\n */\nclass InvalidMessageError extends Error {\n  constructor(msg, errorDetail) {\n    super(`The message '${msg}' is invalid. ${errorDetail}`);\n    this.msg = msg;\n    this.errorDetail = errorDetail;\n    this.name = 'InvalidMessageError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid contract address being passed or used\r\n */\nclass InvalidContractAddressError extends Error {\n  constructor(contractAddress) {\n    super(`The contract address '${contractAddress}' is invalid`);\n    this.contractAddress = contractAddress;\n    this.name = 'InvalidContractAddressError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid address being passed or used (both contract and implicit)\r\n */\nclass InvalidAddressError extends Error {\n  constructor(address) {\n    super(`The address '${address}' is invalid`);\n    this.address = address;\n    this.name = 'InvalidAddressError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid chain id being passed or used\r\n */\nclass InvalidChainIdError extends Error {\n  constructor(chainId) {\n    super(`The chain id '${chainId}' is invalid`);\n    this.chainId = chainId;\n    this.name = 'InvalidChainIdError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid key hash being passed or used\r\n */\nclass InvalidKeyHashError extends Error {\n  constructor(keyHash) {\n    super(`The public key hash '${keyHash}' is invalid`);\n    this.keyHash = keyHash;\n    this.name = 'InvalidKeyHashError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid block hash being passed or used\r\n */\nclass InvalidBlockHashError extends Error {\n  constructor(blockHash) {\n    super(`The block hash '${blockHash}' is invalid`);\n    this.blockHash = blockHash;\n    this.name = 'InvalidBlockHashError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates invalid protocol hash being passed or used\r\n */\nclass InvalidProtocolHashError extends Error {\n  constructor(protocolHash) {\n    super(`The protocol hash '${protocolHash}' is invalid`);\n    this.protocolHash = protocolHash;\n    this.name = 'InvalidProtocolHashError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid operation hash being passed or used\r\n */\nclass InvalidOperationHashError extends Error {\n  constructor(operationHash) {\n    super(`The operation hash '${operationHash}' is invalid`);\n    this.operationHash = operationHash;\n    this.name = 'InvalidOperationHashError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid operation kind being passed or used\r\n */\nclass InvalidOperationKindError extends Error {\n  constructor(operationKind) {\n    super(`The operation kind '${operationKind}' is unsupported`);\n    this.operationKind = operationKind;\n    this.name = 'InvalidOperationKindError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates something is no longer supported and/or deprecated\r\n */\nclass DeprecationError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'DeprecationError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates an action is prohibited or not allowed\r\n */\nclass ProhibitedActionError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'ProhibitedActionError';\n  }\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates a failure when trying to convert data from one type to another\r\n */\nclass ValueConversionError extends Error {\n  constructor(value, desiredType) {\n    super(`Unable to convert ${value} to a ${desiredType}`);\n    this.value = value;\n    this.desiredType = desiredType;\n    this.name = 'ValueConversionError';\n  }\n}\n\n/**\r\n * @description Verify signature of a payload\r\n *\r\n * @param messageBytes The forged message including the magic byte (11 for block,\r\n *        12 for preendorsement, 13 for endorsement, 3 for generic, 5 for the PACK format of michelson)\r\n * @param publicKey The public key to verify the signature against\r\n * @param signature The signature to verify\r\n * @returns A boolean indicating if the signature matches\r\n *\r\n * @example\r\n * ```\r\n * const message = '03d0c10e3ed11d7c6e3357f6ef335bab9e8f2bd54d0ce20c482e241191a6e4b8ce6c01be917311d9ac46959750e405d57e268e2ed9e174a80794fbd504e12a4a000141eb3781afed2f69679ff2bbe1c5375950b0e40d00ff000000005e05050505050507070100000024747a32526773486e74516b72794670707352466261313652546656503539684b72654a4d07070100000024747a315a6672455263414c42776d4171776f6e525859565142445439426a4e6a42484a750001';\r\n * const pk = 'sppk7c7hkPj47yjYFEHX85q46sFJGw6RBrqoVSHwAJAT4e14KJwzoey';\r\n * const sig = 'spsig1cdLkp1RLgUHAp13aRFkZ6MQDPp7xCnjAExGL3MBSdMDmT6JgQSX8cufyDgJRM3sinFtiCzLbsyP6d365EHoNevxhT47nx'\r\n *\r\n * const response = verifySignature(message, pk, sig);\r\n * ```\r\n *\r\n */\nfunction verifySignature(messageBytes, publicKey, signature) {\n  const pkPrefix = validatePkAndExtractPrefix(publicKey);\n  const sigPrefix = validateSigAndExtractPrefix(signature);\n  const decodedPublicKey = b58cdecode(publicKey, prefix[pkPrefix]);\n  const decodedSig = b58cdecode(signature, prefix[sigPrefix]);\n  const bytesHash = hash(hex2buf(validateMessageNotEmpty(messageBytes)), 32);\n  if (pkPrefix === Prefix.EDPK) {\n    return verifyEdSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.SPPK) {\n    return verifySpSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.P2PK) {\n    return verifyP2Signature(decodedSig, bytesHash, decodedPublicKey);\n  } else {\n    return false;\n  }\n}\nfunction validateMessageNotEmpty(message) {\n  if (message === '') {\n    throw new InvalidMessageError(message, 'The message provided for verifying signature cannot be empty.');\n  }\n  return message;\n}\nfunction validatePkAndExtractPrefix(publicKey) {\n  if (publicKey === '') {\n    throw new InvalidPublicKeyError(publicKey, 'Public key cannot be empty');\n  }\n  const pkPrefix = publicKey.substring(0, 4);\n  const validation = validatePublicKey(publicKey);\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid checksum');\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidPublicKeyError(publicKey, `The public key provided has an unsupported prefix: ${pkPrefix}`);\n    }\n  }\n  return pkPrefix;\n}\nfunction validateSigAndExtractPrefix(signature) {\n  const signaturePrefix = signature.startsWith('sig') ? signature.substr(0, 3) : signature.substr(0, 5);\n  const validation = validateSignature(signature);\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidSignatureError(signature, `invalid checksum`);\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidSignatureError(signature, 'invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidSignatureError(signaturePrefix, 'unsupported prefix');\n    }\n  }\n  return signaturePrefix;\n}\nfunction verifyEdSignature(decodedSig, bytesHash, decodedPublicKey) {\n  try {\n    return verify(decodedPublicKey, bytesHash, decodedSig);\n  } catch (e) {\n    return false;\n  }\n}\nfunction verifySpSignature(decodedSig, bytesHash, decodedPublicKey) {\n  const key = new elliptic.ec('secp256k1').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\nfunction verifyP2Signature(decodedSig, bytesHash, decodedPublicKey) {\n  const key = new elliptic.ec('p256').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\nfunction verifySpOrP2Sig(decodedSig, bytesHash, key) {\n  const hexSig = buf2hex(toBuffer(decodedSig));\n  const match = hexSig.match(/([a-f\\d]{64})/gi);\n  if (match) {\n    try {\n      const [r, s] = match;\n      return key.verify(bytesHash, {\n        r,\n        s\n      });\n    } catch (e) {\n      return false;\n    }\n  }\n  return false;\n}\nvar ValidationResult;\n(function (ValidationResult) {\n  ValidationResult[ValidationResult[\"NO_PREFIX_MATCHED\"] = 0] = \"NO_PREFIX_MATCHED\";\n  ValidationResult[ValidationResult[\"INVALID_CHECKSUM\"] = 1] = \"INVALID_CHECKSUM\";\n  ValidationResult[ValidationResult[\"INVALID_LENGTH\"] = 2] = \"INVALID_LENGTH\";\n  ValidationResult[ValidationResult[\"VALID\"] = 3] = \"VALID\";\n})(ValidationResult || (ValidationResult = {}));\nfunction isValidPrefix(value) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n  return value in prefix;\n}\n/**\r\n * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).\r\n * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,\r\n * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,\r\n * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.\r\n * If all checks pass, return `VALID`.\r\n *\r\n * @param value Value to validate\r\n * @param prefixes prefix the value should have\r\n */\nfunction validatePrefixedValue(value, prefixes) {\n  const match = new RegExp(`^(${prefixes.join('|')})`).exec(value);\n  if (!match || match.length === 0) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n  const prefixKey = match[0];\n  if (!isValidPrefix(prefixKey)) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n  // Remove annotation from contract address before doing the validation\n  const contractAddress = /^(KT1\\w{33})(%(.*))?/.exec(value);\n  if (contractAddress) {\n    value = contractAddress[1];\n  }\n  // decodeUnsafe return undefined if decoding fail\n  let decoded = bs58check.decodeUnsafe(value);\n  if (!decoded) {\n    return ValidationResult.INVALID_CHECKSUM;\n  }\n  decoded = decoded.slice(prefix[prefixKey].length);\n  if (decoded.length !== prefixLength[prefixKey]) {\n    return ValidationResult.INVALID_LENGTH;\n  }\n  return ValidationResult.VALID;\n}\nconst implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3, Prefix.TZ4];\nconst contractPrefix = [Prefix.KT1, Prefix.TXR1];\nconst signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];\nconst pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK];\nconst operationPrefix = [Prefix.O];\nconst protocolPrefix = [Prefix.P];\nconst blockPrefix = [Prefix.B];\n/**\r\n * @description Used to check if an address or a contract address is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateAddress } from '@taquito/utils';\r\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\r\n * const validation = validateAddress(pkh)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\nfunction validateAddress(value) {\n  return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix]);\n}\n/**\r\n * @description Used to check if a chain id is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateChain } from '@taquito/utils';\r\n * const chainId = 'NetXdQprcVkpaWU'\r\n * const validation = validateChain(chainId)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\nfunction validateChain(value) {\n  return validatePrefixedValue(value, [Prefix.NET]);\n}\n/**\r\n * @description Used to check if a contract address is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateContractAddress } from '@taquito/utils';\r\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\r\n * const validation = validateContractAddress(contractAddress)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\nfunction validateContractAddress(value) {\n  return validatePrefixedValue(value, contractPrefix);\n}\n/**\r\n * @description Used to check if a key hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateKeyHash } from '@taquito/utils';\r\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\r\n * const validation = validateKeyHash(keyHashWithoutPrefix)\r\n * console.log(validation)\r\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\r\n * ```\r\n */\nfunction validateKeyHash(value) {\n  return validatePrefixedValue(value, implicitPrefix);\n}\n/**\r\n * @description Used to check if a signature is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateSignature } from '@taquito/utils';\r\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\r\n * const validation = validateSignature(signature)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\nfunction validateSignature(value) {\n  return validatePrefixedValue(value, signaturePrefix);\n}\n/**\r\n * @description Used to check if a public key is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validatePublicKey } from '@taquito/utils';\r\n * const publicKey = 'edpkvS5QFv7KRGfa3b87gg9DBpxSm3NpSwnjhUjNBQrRUUR66F7C9g'\r\n * const validation = validatePublicKey(publicKey)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\nfunction validatePublicKey(value) {\n  return validatePrefixedValue(value, pkPrefix);\n}\n/**\r\n * @description Used to check if an operation hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateOperation } from '@taquito/utils';\r\n * const operationHash = 'oo6JPEAy8VuMRGaFuMmLNFFGdJgiaKfnmT1CpHJfKP3Ye5ZahiP'\r\n * const validation = validateOperation(operationHash)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\nfunction validateOperation(value) {\n  return validatePrefixedValue(value, operationPrefix);\n}\n/**\r\n * @description Used to check if a protocol hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateProtocol } from '@taquito/utils';\r\n * const protocolHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\r\n * const validation = validateProtocol(protocolHash)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\nfunction validateProtocol(value) {\n  return validatePrefixedValue(value, protocolPrefix);\n}\n/**\r\n * @description Used to check if a block hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateBlock } from '@taquito/utils';\r\n * const blockHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\r\n * const validation = validateBlock(blockHash)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\nfunction validateBlock(value) {\n  return validatePrefixedValue(value, blockPrefix);\n}\n\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nconst VERSION = {\n  \"commitHash\": \"38da814ec2bb4e81c7ad5a45b6b183a4d0b8dc25\",\n  \"version\": \"12.1.1\"\n};\n\n/**\r\n * @packageDocumentation\r\n * @module @taquito/utils\r\n */\n/**\r\n *\r\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\r\n *\r\n * @param value Value in hex\r\n */\nfunction encodeExpr(value) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix['expr']);\n}\n/**\r\n *\r\n * @description Return the operation hash of a signed operation\r\n * @param value Value in hex of a signed operation\r\n */\nfunction encodeOpHash(value) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix.o);\n}\n/**\r\n *\r\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\r\n *\r\n * @param value Value to base58 encode\r\n * @param prefix prefix to append to the encoded string\r\n */\nfunction b58cencode(value, prefix) {\n  const payloadAr = typeof value === 'string' ? Uint8Array.from(Buffer.from(value, 'hex')) : value;\n  const n = new Uint8Array(prefix.length + payloadAr.length);\n  n.set(prefix);\n  n.set(payloadAr, prefix.length);\n  return bs58check.encode(Buffer.from(n.buffer));\n}\n/**\r\n *\r\n * @description Base58 decode a string and remove the prefix from it\r\n *\r\n * @param value Value to base58 decode\r\n * @param prefix prefix to remove from the decoded string\r\n */\nconst b58cdecode = (enc, prefixArg) => bs58check.decode(enc).slice(prefixArg.length);\n/**\r\n *\r\n * @description Base58 decode a string with predefined prefix\r\n *\r\n * @param value Value to base58 decode\r\n */\nfunction b58decode(payload) {\n  const buf = bs58check.decode(payload);\n  const prefixMap = {\n    [prefix.tz1.toString()]: '0000',\n    [prefix.tz2.toString()]: '0001',\n    [prefix.tz3.toString()]: '0002'\n  };\n  const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];\n  if (pref) {\n    // tz addresses\n    const hex = buf2hex(buf.slice(3));\n    return pref + hex;\n  } else {\n    // other (kt addresses)\n    return '01' + buf2hex(buf.slice(3, 42)) + '00';\n  }\n}\n/**\r\n *\r\n * @description Base58 encode an address using predefined prefix\r\n *\r\n * @param value Address to base58 encode (tz1, tz2, tz3 or KT1)\r\n */\nfunction encodePubKey(value) {\n  if (value.substring(0, 2) === '00') {\n    const pref = {\n      '0000': prefix.tz1,\n      '0001': prefix.tz2,\n      '0002': prefix.tz3\n    };\n    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);\n  }\n  return b58cencode(value.substring(2, 42), prefix.KT);\n}\n/**\r\n *\r\n * @description Base58 encode a key according to its prefix\r\n *\r\n * @param value Key to base58 encode\r\n */\nfunction encodeKey(value) {\n  if (value[0] === '0') {\n    const pref = {\n      '00': new Uint8Array([13, 15, 37, 217]),\n      '01': new Uint8Array([3, 254, 226, 86]),\n      '02': new Uint8Array([3, 178, 139, 127])\n    };\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n/**\r\n *\r\n * @description Base58 encode a key hash according to its prefix\r\n *\r\n * @param value Key hash to base58 encode\r\n */\nfunction encodeKeyHash(value) {\n  if (value[0] === '0') {\n    const pref = {\n      '00': new Uint8Array([6, 161, 159]),\n      '01': new Uint8Array([6, 161, 161]),\n      '02': new Uint8Array([6, 161, 164])\n    };\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n/**\r\n *\r\n * @description Convert an hex string to a Uint8Array\r\n *\r\n * @param hex Hex string to convert\r\n */\nconst hex2buf = hex => {\n  const match = hex.match(/[\\da-f]{2}/gi);\n  if (match) {\n    return new Uint8Array(match.map(h => parseInt(h, 16)));\n  } else {\n    throw new ValueConversionError(hex, 'Uint8Array');\n  }\n};\n/**\r\n *\r\n * @description Merge 2 buffers together\r\n *\r\n * @param b1 First buffer\r\n * @param b2 Second buffer\r\n */\nconst mergebuf = (b1, b2) => {\n  const r = new Uint8Array(b1.length + b2.length);\n  r.set(b1);\n  r.set(b2, b1.length);\n  return r;\n};\n/**\r\n *\r\n * @description Flatten a michelson json representation to an array\r\n *\r\n * @param s michelson json\r\n */\n// TODO Zainen check use\nconst mic2arr = function me2(s) {\n  let ret = [];\n  if (Object.prototype.hasOwnProperty.call(s, 'prim')) {\n    if (s.prim === 'Pair') {\n      ret.push(me2(s.args[0]));\n      ret = ret.concat(me2(s.args[1]));\n    } else if (s.prim === 'Elt') {\n      ret = {\n        key: me2(s.args[0]),\n        val: me2(s.args[1])\n      };\n    } else if (s.prim === 'True') {\n      ret = true;\n    } else if (s.prim === 'False') {\n      ret = false;\n    }\n  } else if (Array.isArray(s)) {\n    const sc = s.length;\n    for (let i = 0; i < sc; i++) {\n      const n = me2(s[i]);\n      if (typeof n.key !== 'undefined') {\n        if (Array.isArray(ret)) {\n          ret = {\n            keys: [],\n            vals: []\n          };\n        }\n        ret.keys.push(n.key);\n        ret.vals.push(n.val);\n      } else {\n        ret.push(n);\n      }\n    }\n  } else if (Object.prototype.hasOwnProperty.call(s, 'string')) {\n    ret = s.string;\n  } else if (Object.prototype.hasOwnProperty.call(s, 'int')) {\n    ret = parseInt(s.int, 10);\n  } else {\n    ret = s;\n  }\n  return ret;\n};\n/**\r\n *\r\n * @description Convert a buffer to an hex string\r\n *\r\n * @param buffer Buffer to convert\r\n */\nconst buf2hex = buffer => {\n  const byteArray = new Uint8Array(buffer);\n  const hexParts = [];\n  byteArray.forEach(byte => {\n    const hex = byte.toString(16);\n    const paddedHex = `00${hex}`.slice(-2);\n    hexParts.push(paddedHex);\n  });\n  return hexParts.join('');\n};\n/**\r\n *\r\n *  @description Gets Tezos address (PKH) from Public Key\r\n *\r\n *  @param publicKey Public Key\r\n *  @returns A string of the Tezos address (PKH) that was derived from the given Public Key\r\n */\nconst getPkhfromPk = publicKey => {\n  let encodingPrefix;\n  let prefixLen;\n  const keyPrefix = validatePkAndExtractPrefix(publicKey);\n  const decoded = b58cdecode(publicKey, prefix[keyPrefix]);\n  switch (keyPrefix) {\n    case Prefix.EDPK:\n      encodingPrefix = prefix[Prefix.TZ1];\n      prefixLen = prefixLength[Prefix.TZ1];\n      break;\n    case Prefix.SPPK:\n      encodingPrefix = prefix[Prefix.TZ2];\n      prefixLen = prefixLength[Prefix.TZ2];\n      break;\n    case Prefix.P2PK:\n      encodingPrefix = prefix[Prefix.TZ3];\n      prefixLen = prefixLength[Prefix.TZ3];\n      break;\n  }\n  const hashed = hash(decoded, prefixLen);\n  const result = b58cencode(hashed, encodingPrefix);\n  return result;\n};\n/**\r\n *\r\n * @description Convert a string to bytes\r\n *\r\n * @param str String to convert\r\n */\nfunction char2Bytes(str) {\n  return Buffer.from(str, 'utf8').toString('hex');\n}\n/**\r\n *\r\n * @description Convert bytes to a string\r\n *\r\n * @param str Bytes to convert\r\n */\nfunction bytes2Char(hex) {\n  return Buffer.from(hex2buf(hex)).toString('utf8');\n}\nexport { DeprecationError, InvalidAddressError, InvalidBlockHashError, InvalidChainIdError, InvalidContractAddressError, InvalidKeyError, InvalidKeyHashError, InvalidMessageError, InvalidOperationHashError, InvalidOperationKindError, InvalidProtocolHashError, InvalidPublicKeyError, InvalidSignatureError, Prefix, ProhibitedActionError, VERSION, ValidationResult, ValueConversionError, b58cdecode, b58cencode, b58decode, buf2hex, bytes2Char, char2Bytes, encodeExpr, encodeKey, encodeKeyHash, encodeOpHash, encodePubKey, getPkhfromPk, hex2buf, isValidPrefix, mergebuf, mic2arr, prefix, prefixLength, validateAddress, validateBlock, validateChain, validateContractAddress, validateKeyHash, validateOperation, validatePkAndExtractPrefix, validateProtocol, validatePublicKey, validateSignature, verifySignature };","map":{"version":3,"names":["Prefix","prefix","TZ1","Uint8Array","TZ2","TZ3","TZ4","KT","KT1","EDSK","EDSK2","SPSK","P2SK","EDPK","SPPK","P2PK","EDESK","SPESK","P2ESK","EDSIG","SPSIG","P2SIG","SIG","NET","NCE","B","O","LO","LLO","P","CO","ID","EXPR","TZ","VH","TXR1","TXI","TXM","TXC","TXMR","TXRL","TXW","prefixLength","InvalidKeyError","Error","constructor","key","errorDetail","name","InvalidPublicKeyError","publicKey","InvalidSignatureError","signature","InvalidMessageError","msg","InvalidContractAddressError","contractAddress","InvalidAddressError","address","InvalidChainIdError","chainId","InvalidKeyHashError","keyHash","InvalidBlockHashError","blockHash","InvalidProtocolHashError","protocolHash","InvalidOperationHashError","operationHash","InvalidOperationKindError","operationKind","DeprecationError","message","ProhibitedActionError","ValueConversionError","value","desiredType","verifySignature","messageBytes","pkPrefix","validatePkAndExtractPrefix","sigPrefix","validateSigAndExtractPrefix","decodedPublicKey","b58cdecode","decodedSig","bytesHash","hash","hex2buf","validateMessageNotEmpty","verifyEdSignature","verifySpSignature","verifyP2Signature","substring","validation","validatePublicKey","ValidationResult","VALID","INVALID_CHECKSUM","INVALID_LENGTH","NO_PREFIX_MATCHED","signaturePrefix","startsWith","substr","validateSignature","verify","e","elliptic","ec","keyFromPublic","verifySpOrP2Sig","hexSig","buf2hex","toBuffer","match","r","s","isValidPrefix","validatePrefixedValue","prefixes","RegExp","join","exec","length","prefixKey","decoded","bs58check","decodeUnsafe","slice","implicitPrefix","contractPrefix","operationPrefix","protocolPrefix","blockPrefix","validateAddress","validateChain","validateContractAddress","validateKeyHash","validateOperation","validateProtocol","validateBlock","VERSION","encodeExpr","blakeHash","blake","blake2b","undefined","b58cencode","encodeOpHash","o","payloadAr","from","Buffer","n","set","encode","buffer","enc","prefixArg","decode","b58decode","payload","buf","prefixMap","tz1","toString","tz2","tz3","pref","hex","encodePubKey","encodeKey","encodeKeyHash","map","h","parseInt","mergebuf","b1","b2","mic2arr","me2","ret","Object","prototype","hasOwnProperty","call","prim","push","args","concat","val","Array","isArray","sc","i","keys","vals","string","int","byteArray","hexParts","forEach","byte","paddedHex","getPkhfromPk","encodingPrefix","prefixLen","keyPrefix","hashed","result","char2Bytes","str","bytes2Char"],"sources":["../src/constants.ts","../src/errors.ts","../src/verify-signature.ts","../src/validators.ts","../src/version.ts","../src/taquito-utils.ts"],"sourcesContent":["export enum Prefix {\n  TZ1 = 'tz1',\n  TZ2 = 'tz2',\n  TZ3 = 'tz3',\n  TZ4 = 'tz4',\n  KT = 'KT',\n  KT1 = 'KT1',\n\n  EDSK2 = 'edsk2',\n  SPSK = 'spsk',\n  P2SK = 'p2sk',\n\n  EDPK = 'edpk',\n  SPPK = 'sppk',\n  P2PK = 'p2pk',\n\n  EDESK = 'edesk',\n  SPESK = 'spesk',\n  P2ESK = 'p2esk',\n\n  EDSK = 'edsk',\n  EDSIG = 'edsig',\n  SPSIG = 'spsig',\n  P2SIG = 'p2sig',\n  SIG = 'sig',\n\n  NET = 'Net',\n  NCE = 'nce',\n  B = 'B',\n  O = 'o',\n  LO = 'Lo',\n  LLO = 'LLo',\n  P = 'P',\n  CO = 'Co',\n  ID = 'id',\n\n  EXPR = 'expr',\n  TZ = 'TZ',\n\n  VH = 'vh', // block_payload_hash\n\n  //rollups\n  TXR1 = 'txr1',\n  TXI = 'txi',\n  TXM = 'txm',\n  TXC = 'txc',\n  TXMR = 'txmr',\n  TXRL = 'txM',\n  TXW = 'txw',\n\n}\n\nexport const prefix = {\n  [Prefix.TZ1]: new Uint8Array([6, 161, 159]),\n  [Prefix.TZ2]: new Uint8Array([6, 161, 161]),\n  [Prefix.TZ3]: new Uint8Array([6, 161, 164]),\n  [Prefix.TZ4]: new Uint8Array([6, 161, 166]),\n  [Prefix.KT]: new Uint8Array([2, 90, 121]),\n  [Prefix.KT1]: new Uint8Array([2, 90, 121]),\n\n  [Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),\n  [Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),\n  [Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),\n  [Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),\n\n  [Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),\n  [Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),\n  [Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),\n\n  [Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),\n  [Prefix.SPESK]: new Uint8Array([0x09, 0xed, 0xf1, 0xae, 0x96]),\n  [Prefix.P2ESK]: new Uint8Array([0x09, 0x30, 0x39, 0x73, 0xab]),\n\n  [Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),\n  [Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),\n  [Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),\n  [Prefix.SIG]: new Uint8Array([4, 130, 43]),\n\n  [Prefix.NET]: new Uint8Array([87, 82, 0]),\n  [Prefix.NCE]: new Uint8Array([69, 220, 169]),\n  [Prefix.B]: new Uint8Array([1, 52]),\n  [Prefix.O]: new Uint8Array([5, 116]),\n  [Prefix.LO]: new Uint8Array([133, 233]),\n  [Prefix.LLO]: new Uint8Array([29, 159, 109]),\n  [Prefix.P]: new Uint8Array([2, 170]),\n  [Prefix.CO]: new Uint8Array([79, 179]),\n  [Prefix.ID]: new Uint8Array([153, 103]),\n\n  [Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),\n  // Legacy prefix\n  [Prefix.TZ]: new Uint8Array([2, 90, 121]),\n\n  [Prefix.VH]: new Uint8Array([1, 106, 242]),\n\n  [Prefix.TXR1]: new Uint8Array([1, 128, 120, 31]),\n  [Prefix.TXI]: new Uint8Array([79, 148, 196]),\n  [Prefix.TXM]: new Uint8Array([79, 149, 30]),\n  [Prefix.TXC]: new Uint8Array([79, 148, 17]),\n  [Prefix.TXMR]: new Uint8Array([18, 7, 206, 87]),\n  [Prefix.TXRL]: new Uint8Array([79, 146, 82]),\n  [Prefix.TXW]: new Uint8Array([79, 150, 72]),\n   \n};\n\nexport const prefixLength: { [key: string]: number } = {\n  [Prefix.TZ1]: 20,\n  [Prefix.TZ2]: 20,\n  [Prefix.TZ3]: 20,\n  [Prefix.TZ4]: 20,\n  [Prefix.KT]: 20,\n  [Prefix.KT1]: 20,\n\n  [Prefix.EDPK]: 32,\n  [Prefix.SPPK]: 33,\n  [Prefix.P2PK]: 33,\n  [Prefix.EDSIG]: 64,\n  [Prefix.SPSIG]: 64,\n  [Prefix.P2SIG]: 64,\n  [Prefix.SIG]: 64,\n  [Prefix.NET]: 4,\n  [Prefix.B]: 32,\n  [Prefix.P]: 32,\n  [Prefix.O]: 32,\n  [Prefix.VH]: 32,\n  [Prefix.TXR1]: 20,\n  [Prefix.TXI]: 32,\n  [Prefix.TXM]: 32,\n  [Prefix.TXC]: 32,\n  [Prefix.TXMR]: 32,\n  [Prefix.TXRL]: 32,\n  [Prefix.TXW]: 32,\n\n};\n","/**\n *  @category Error\n *  @description Error that indicates an invalid key being passed or used\n */\nexport class InvalidKeyError extends Error {\n  public name = 'InvalidKeyError';\n  constructor(public key: string, public errorDetail?: string) {\n    super(`The key ${key} is invalid. ${errorDetail}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an Invalid Public Key being passed or used\n */\nexport class InvalidPublicKeyError extends Error {\n  public name = 'InvalidPublicKeyError';\n  constructor(public publicKey: string, errorDetail?: string) {\n    super(`The public key '${publicKey}' is invalid. ${errorDetail}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid signature being passed or used\n */\nexport class InvalidSignatureError extends Error {\n  public name = 'InvalidSignatureError';\n  constructor(public signature: string, errorDetail?: string) {\n    super(`The signature '${signature}' is invalid (${errorDetail})`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid message being passed or used\n */\nexport class InvalidMessageError extends Error {\n  public name = 'InvalidMessageError';\n  constructor(public msg: string, public errorDetail?: string) {\n    super(`The message '${msg}' is invalid. ${errorDetail}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid contract address being passed or used\n */\nexport class InvalidContractAddressError extends Error {\n  public name = 'InvalidContractAddressError';\n  constructor(public contractAddress: string) {\n    super(`The contract address '${contractAddress}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid address being passed or used (both contract and implicit)\n */\nexport class InvalidAddressError extends Error {\n  public name = 'InvalidAddressError';\n  constructor(public address: string) {\n    super(`The address '${address}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid chain id being passed or used\n */\nexport class InvalidChainIdError extends Error {\n  public name = 'InvalidChainIdError';\n  constructor(public chainId: string) {\n    super(`The chain id '${chainId}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid key hash being passed or used\n */\nexport class InvalidKeyHashError extends Error {\n  public name = 'InvalidKeyHashError';\n  constructor(public keyHash: string) {\n    super(`The public key hash '${keyHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid block hash being passed or used\n */ export class InvalidBlockHashError extends Error {\n  public name = 'InvalidBlockHashError';\n  constructor(public blockHash: string) {\n    super(`The block hash '${blockHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates invalid protocol hash being passed or used\n */\nexport class InvalidProtocolHashError extends Error {\n  public name = 'InvalidProtocolHashError';\n  constructor(public protocolHash: string) {\n    super(`The protocol hash '${protocolHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation hash being passed or used\n */ export class InvalidOperationHashError extends Error {\n  public name = 'InvalidOperationHashError';\n  constructor(public operationHash: string) {\n    super(`The operation hash '${operationHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation kind being passed or used\n */\nexport class InvalidOperationKindError extends Error {\n  public name = 'InvalidOperationKindError';\n  constructor(public operationKind: string) {\n    super(`The operation kind '${operationKind}' is unsupported`);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates something is no longer supported and/or deprecated\n */\nexport class DeprecationError extends Error {\n  public name = 'DeprecationError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates an action is prohibited or not allowed\n */\nexport class ProhibitedActionError extends Error {\n  public name = 'ProhibitedActionError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates a failure when trying to convert data from one type to another\n */\nexport class ValueConversionError extends Error {\n  public name = 'ValueConversionError';\n  constructor(public value: string, public desiredType: string) {\n    super(`Unable to convert ${value} to a ${desiredType}`);\n  }\n}\n","import { verify } from '@stablelib/ed25519';\nimport { hash } from '@stablelib/blake2b';\nimport {\n  b58cdecode,\n  buf2hex,\n  hex2buf,\n  Prefix,\n  prefix,\n  validatePublicKey,\n  validateSignature,\n  ValidationResult,\n} from './taquito-utils';\nimport elliptic from 'elliptic';\nimport toBuffer from 'typedarray-to-buffer';\nimport { InvalidMessageError, InvalidPublicKeyError, InvalidSignatureError } from './errors';\n\ntype PkPrefix = Prefix.EDPK | Prefix.SPPK | Prefix.P2PK;\ntype SigPrefix = Prefix.EDSIG | Prefix.SPSIG | Prefix.P2SIG | Prefix.SIG;\n\n/**\n * @description Verify signature of a payload\n *\n * @param messageBytes The forged message including the magic byte (11 for block,\n *        12 for preendorsement, 13 for endorsement, 3 for generic, 5 for the PACK format of michelson)\n * @param publicKey The public key to verify the signature against\n * @param signature The signature to verify\n * @returns A boolean indicating if the signature matches\n *\n * @example\n * ```\n * const message = '03d0c10e3ed11d7c6e3357f6ef335bab9e8f2bd54d0ce20c482e241191a6e4b8ce6c01be917311d9ac46959750e405d57e268e2ed9e174a80794fbd504e12a4a000141eb3781afed2f69679ff2bbe1c5375950b0e40d00ff000000005e05050505050507070100000024747a32526773486e74516b72794670707352466261313652546656503539684b72654a4d07070100000024747a315a6672455263414c42776d4171776f6e525859565142445439426a4e6a42484a750001';\n * const pk = 'sppk7c7hkPj47yjYFEHX85q46sFJGw6RBrqoVSHwAJAT4e14KJwzoey';\n * const sig = 'spsig1cdLkp1RLgUHAp13aRFkZ6MQDPp7xCnjAExGL3MBSdMDmT6JgQSX8cufyDgJRM3sinFtiCzLbsyP6d365EHoNevxhT47nx'\n *\n * const response = verifySignature(message, pk, sig);\n * ```\n *\n */\nexport function verifySignature(\n  messageBytes: string,\n  publicKey: string,\n  signature: string\n): boolean {\n  const pkPrefix = validatePkAndExtractPrefix(publicKey);\n  const sigPrefix = validateSigAndExtractPrefix(signature);\n\n  const decodedPublicKey = b58cdecode(publicKey, prefix[pkPrefix]);\n  const decodedSig = b58cdecode(signature, prefix[sigPrefix]);\n  const bytesHash = hash(hex2buf(validateMessageNotEmpty(messageBytes)), 32);\n\n  if (pkPrefix === Prefix.EDPK) {\n    return verifyEdSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.SPPK) {\n    return verifySpSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.P2PK) {\n    return verifyP2Signature(decodedSig, bytesHash, decodedPublicKey);\n  } else {\n    return false;\n  }\n}\n\nfunction validateMessageNotEmpty(message: string) {\n  if (message === '') {\n    throw new InvalidMessageError(\n      message,\n      'The message provided for verifying signature cannot be empty.'\n    );\n  }\n  return message;\n}\n\nexport function validatePkAndExtractPrefix(publicKey: string): PkPrefix {\n  if (publicKey === '') {\n    throw new InvalidPublicKeyError(publicKey, 'Public key cannot be empty');\n  }\n  const pkPrefix = publicKey.substring(0, 4);\n  const validation = validatePublicKey(publicKey);\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid checksum');\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidPublicKeyError(\n        publicKey,\n        `The public key provided has an unsupported prefix: ${pkPrefix}`\n      );\n    }\n  }\n  return pkPrefix as PkPrefix;\n}\n\nfunction validateSigAndExtractPrefix(signature: string): SigPrefix {\n  const signaturePrefix = signature.startsWith('sig')\n    ? signature.substr(0, 3)\n    : signature.substr(0, 5);\n  const validation = validateSignature(signature);\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidSignatureError(signature, `invalid checksum`);\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidSignatureError(signature, 'invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidSignatureError(signaturePrefix, 'unsupported prefix');\n    }\n  }\n  return signaturePrefix as SigPrefix;\n}\n\nfunction verifyEdSignature(\n  decodedSig: Uint8Array,\n  bytesHash: Uint8Array,\n  decodedPublicKey: Uint8Array\n) {\n  try {\n    return verify(decodedPublicKey, bytesHash, decodedSig);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction verifySpSignature(\n  decodedSig: Uint8Array,\n  bytesHash: Uint8Array,\n  decodedPublicKey: Uint8Array\n) {\n  const key = new elliptic.ec('secp256k1').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifyP2Signature(\n  decodedSig: Uint8Array,\n  bytesHash: Uint8Array,\n  decodedPublicKey: Uint8Array\n) {\n  const key = new elliptic.ec('p256').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifySpOrP2Sig(decodedSig: Uint8Array, bytesHash: Uint8Array, key: elliptic.ec.KeyPair) {\n  const hexSig = buf2hex(toBuffer(decodedSig));\n  const match = hexSig.match(/([a-f\\d]{64})/gi);\n  if (match) {\n    try {\n      const [r, s] = match;\n      return key.verify(bytesHash, { r, s });\n    } catch (e) {\n      return false;\n    }\n  }\n  return false;\n}\n","import { prefix, prefixLength, Prefix } from './constants';\n\nimport bs58check from 'bs58check';\n\nexport enum ValidationResult {\n  NO_PREFIX_MATCHED,\n  INVALID_CHECKSUM,\n  INVALID_LENGTH,\n  VALID,\n}\n\nexport function isValidPrefix(value: unknown): value is Prefix {\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  return value in prefix;\n}\n/**\n * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).\n * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,\n * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,\n * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.\n * If all checks pass, return `VALID`.\n *\n * @param value Value to validate\n * @param prefixes prefix the value should have\n */\nfunction validatePrefixedValue(value: string, prefixes: Prefix[]) {\n\n  const match = new RegExp(`^(${prefixes.join('|')})`).exec(value);\n  if (!match || match.length === 0) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  const prefixKey = match[0];\n\n  if (!isValidPrefix(prefixKey)) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  // Remove annotation from contract address before doing the validation\n  const contractAddress = /^(KT1\\w{33})(%(.*))?/.exec(value);\n  if (contractAddress) {\n    value = contractAddress[1];\n  }\n\n  // decodeUnsafe return undefined if decoding fail\n  let decoded = bs58check.decodeUnsafe(value);\n  if (!decoded) {\n    return ValidationResult.INVALID_CHECKSUM;\n  }\n\n  decoded = decoded.slice(prefix[prefixKey].length);\n  if (decoded.length !== prefixLength[prefixKey]) {\n    return ValidationResult.INVALID_LENGTH;\n  }\n\n  return ValidationResult.VALID;\n}\n\nconst implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3,Prefix.TZ4];\nconst contractPrefix = [Prefix.KT1,Prefix.TXR1];\nconst signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];\nconst pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK];\nconst operationPrefix = [Prefix.O];\nconst protocolPrefix = [Prefix.P];\nconst blockPrefix = [Prefix.B]\n\n/**\n * @description Used to check if an address or a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateAddress } from '@taquito/utils';\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateAddress(pkh)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateAddress(value: string): ValidationResult {\n  return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix]);\n}\n\n/**\n * @description Used to check if a chain id is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateChain } from '@taquito/utils';\n * const chainId = 'NetXdQprcVkpaWU'\n * const validation = validateChain(chainId)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateChain(value: string): ValidationResult {\n  return validatePrefixedValue(value, [Prefix.NET]);\n}\n\n/**\n * @description Used to check if a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateContractAddress } from '@taquito/utils';\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\n * const validation = validateContractAddress(contractAddress)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateContractAddress(value: string): ValidationResult {\n  return validatePrefixedValue(value, contractPrefix);\n}\n\n/**\n * @description Used to check if a key hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateKeyHash } from '@taquito/utils';\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateKeyHash(keyHashWithoutPrefix)\n * console.log(validation)\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\n * ```\n */\nexport function validateKeyHash(value: string): ValidationResult {\n  return validatePrefixedValue(value, implicitPrefix);\n}\n\n/**\n * @description Used to check if a signature is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateSignature } from '@taquito/utils';\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\n * const validation = validateSignature(signature)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateSignature(value: string): ValidationResult {\n  return validatePrefixedValue(value, signaturePrefix);\n}\n\n/**\n * @description Used to check if a public key is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validatePublicKey } from '@taquito/utils';\n * const publicKey = 'edpkvS5QFv7KRGfa3b87gg9DBpxSm3NpSwnjhUjNBQrRUUR66F7C9g'\n * const validation = validatePublicKey(publicKey)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validatePublicKey(value: string): ValidationResult {\n  return validatePrefixedValue(value, pkPrefix);\n}\n\n/**\n * @description Used to check if an operation hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateOperation } from '@taquito/utils';\n * const operationHash = 'oo6JPEAy8VuMRGaFuMmLNFFGdJgiaKfnmT1CpHJfKP3Ye5ZahiP'\n * const validation = validateOperation(operationHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateOperation(value: string): ValidationResult {\n  return validatePrefixedValue(value, operationPrefix);\n}\n\n/**\n * @description Used to check if a protocol hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateProtocol } from '@taquito/utils';\n * const protocolHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\n * const validation = validateProtocol(protocolHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateProtocol(value: string): ValidationResult {\n  return validatePrefixedValue(value, protocolPrefix);\n}\n\n/**\n * @description Used to check if a block hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateBlock } from '@taquito/utils';\n * const blockHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\n * const validation = validateBlock(blockHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateBlock(value: string): ValidationResult {\n  return validatePrefixedValue(value, blockPrefix);\n}\n","\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nexport const VERSION = {\n    \"commitHash\": \"38da814ec2bb4e81c7ad5a45b6b183a4d0b8dc25\",\n    \"version\": \"12.1.1\"\n};\n","/**\n * @packageDocumentation\n * @module @taquito/utils\n */\n\n/*\n * Some code in this file is originally from sotez and eztz\n * Copyright (c) 2018 Andrew Kishino\n * Copyright (c) 2017 Stephen Andrews\n */\n\nimport { Buffer } from 'buffer';\nimport { Prefix, prefix, prefixLength } from './constants';\nimport { validatePkAndExtractPrefix } from './verify-signature';\nimport { hash } from '@stablelib/blake2b';\nimport blake from 'blakejs';\nimport bs58check from 'bs58check';\nimport { ValueConversionError } from './errors';\n\nexport * from './validators';\nexport { VERSION } from './version';\n\nexport { prefix, Prefix, prefixLength } from './constants';\n\nexport { verifySignature, validatePkAndExtractPrefix } from './verify-signature';\nexport * from './errors';\n\n/**\n *\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\n *\n * @param value Value in hex\n */\nexport function encodeExpr(value: string) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix['expr']);\n}\n\n/**\n *\n * @description Return the operation hash of a signed operation\n * @param value Value in hex of a signed operation\n */\nexport function encodeOpHash(value: string) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix.o);\n}\n\n/**\n *\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\n *\n * @param value Value to base58 encode\n * @param prefix prefix to append to the encoded string\n */\nexport function b58cencode(value: string | Uint8Array, prefix: Uint8Array) {\n  const payloadAr = typeof value === 'string' ? Uint8Array.from(Buffer.from(value, 'hex')) : value;\n\n  const n = new Uint8Array(prefix.length + payloadAr.length);\n  n.set(prefix);\n  n.set(payloadAr, prefix.length);\n\n  return bs58check.encode(Buffer.from(n.buffer));\n}\n\n/**\n *\n * @description Base58 decode a string and remove the prefix from it\n *\n * @param value Value to base58 decode\n * @param prefix prefix to remove from the decoded string\n */\nexport const b58cdecode = (enc: string, prefixArg: Uint8Array): Uint8Array =>\n  bs58check.decode(enc).slice(prefixArg.length);\n\n/**\n *\n * @description Base58 decode a string with predefined prefix\n *\n * @param value Value to base58 decode\n */\nexport function b58decode(payload: string) {\n  const buf: Buffer = bs58check.decode(payload);\n\n  const prefixMap = {\n    [prefix.tz1.toString()]: '0000',\n    [prefix.tz2.toString()]: '0001',\n    [prefix.tz3.toString()]: '0002',\n  };\n\n  const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];\n  if (pref) {\n    // tz addresses\n    const hex = buf2hex(buf.slice(3));\n    return pref + hex;\n  } else {\n    // other (kt addresses)\n    return '01' + buf2hex(buf.slice(3, 42)) + '00';\n  }\n}\n\n/**\n *\n * @description Base58 encode an address using predefined prefix\n *\n * @param value Address to base58 encode (tz1, tz2, tz3 or KT1)\n */\nexport function encodePubKey(value: string) {\n  if (value.substring(0, 2) === '00') {\n    const pref: { [key: string]: Uint8Array } = {\n      '0000': prefix.tz1,\n      '0001': prefix.tz2,\n      '0002': prefix.tz3,\n    };\n\n    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);\n  }\n\n  return b58cencode(value.substring(2, 42), prefix.KT);\n}\n\n/**\n *\n * @description Base58 encode a key according to its prefix\n *\n * @param value Key to base58 encode\n */\nexport function encodeKey(value: string) {\n  if (value[0] === '0') {\n    const pref: { [key: string]: Uint8Array } = {\n      '00': new Uint8Array([13, 15, 37, 217]),\n      '01': new Uint8Array([3, 254, 226, 86]),\n      '02': new Uint8Array([3, 178, 139, 127]),\n    };\n\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n\n/**\n *\n * @description Base58 encode a key hash according to its prefix\n *\n * @param value Key hash to base58 encode\n */\nexport function encodeKeyHash(value: string) {\n  if (value[0] === '0') {\n    const pref: { [key: string]: Uint8Array } = {\n      '00': new Uint8Array([6, 161, 159]),\n      '01': new Uint8Array([6, 161, 161]),\n      '02': new Uint8Array([6, 161, 164]),\n    };\n\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n\n/**\n *\n * @description Convert an hex string to a Uint8Array\n *\n * @param hex Hex string to convert\n */\nexport const hex2buf = (hex: string): Uint8Array => {\n  const match = hex.match(/[\\da-f]{2}/gi);\n  if (match) {\n    return new Uint8Array(match.map((h) => parseInt(h, 16)));\n  } else {\n    throw new ValueConversionError(hex, 'Uint8Array');\n  }\n};\n\n/**\n *\n * @description Merge 2 buffers together\n *\n * @param b1 First buffer\n * @param b2 Second buffer\n */\nexport const mergebuf = (b1: Uint8Array, b2: Uint8Array): Uint8Array => {\n  const r = new Uint8Array(b1.length + b2.length);\n  r.set(b1);\n  r.set(b2, b1.length);\n  return r;\n};\n\n/**\n *\n * @description Flatten a michelson json representation to an array\n *\n * @param s michelson json\n */\n\n// TODO Zainen check use\nexport const mic2arr = function me2(s: any): any {\n  let ret: any = [];\n  if (Object.prototype.hasOwnProperty.call(s, 'prim')) {\n    if (s.prim === 'Pair') {\n      ret.push(me2(s.args[0]));\n      ret = ret.concat(me2(s.args[1]));\n    } else if (s.prim === 'Elt') {\n      ret = {\n        key: me2(s.args[0]),\n        val: me2(s.args[1]),\n      };\n    } else if (s.prim === 'True') {\n      ret = true;\n    } else if (s.prim === 'False') {\n      ret = false;\n    }\n  } else if (Array.isArray(s)) {\n    const sc = s.length;\n    for (let i = 0; i < sc; i++) {\n      const n = me2(s[i]);\n      if (typeof n.key !== 'undefined') {\n        if (Array.isArray(ret)) {\n          ret = {\n            keys: [],\n            vals: [],\n          };\n        }\n        ret.keys.push(n.key);\n        ret.vals.push(n.val);\n      } else {\n        ret.push(n);\n      }\n    }\n  } else if (Object.prototype.hasOwnProperty.call(s, 'string')) {\n    ret = s.string;\n  } else if (Object.prototype.hasOwnProperty.call(s, 'int')) {\n    ret = parseInt(s.int, 10);\n  } else {\n    ret = s;\n  }\n  return ret;\n};\n\n/**\n *\n * @description Convert a buffer to an hex string\n *\n * @param buffer Buffer to convert\n */\nexport const buf2hex = (buffer: Buffer): string => {\n  const byteArray = new Uint8Array(buffer);\n  const hexParts: string[] = [];\n  byteArray.forEach((byte) => {\n    const hex = byte.toString(16);\n    const paddedHex = `00${hex}`.slice(-2);\n    hexParts.push(paddedHex);\n  });\n  return hexParts.join('');\n};\n\n/**\n *\n *  @description Gets Tezos address (PKH) from Public Key\n *\n *  @param publicKey Public Key\n *  @returns A string of the Tezos address (PKH) that was derived from the given Public Key\n */\nexport const getPkhfromPk = (publicKey: string): string => {\n  let encodingPrefix;\n  let prefixLen;\n\n  const keyPrefix = validatePkAndExtractPrefix(publicKey);\n  const decoded = b58cdecode(publicKey, prefix[keyPrefix]);\n\n  switch (keyPrefix) {\n    case Prefix.EDPK:\n      encodingPrefix = prefix[Prefix.TZ1];\n      prefixLen = prefixLength[Prefix.TZ1];\n      break;\n    case Prefix.SPPK:\n      encodingPrefix = prefix[Prefix.TZ2];\n      prefixLen = prefixLength[Prefix.TZ2];\n      break;\n    case Prefix.P2PK:\n      encodingPrefix = prefix[Prefix.TZ3];\n      prefixLen = prefixLength[Prefix.TZ3];\n      break;\n  }\n\n  const hashed = hash(decoded, prefixLen);\n  const result = b58cencode(hashed, encodingPrefix);\n\n  return result;\n};\n\n/**\n *\n * @description Convert a string to bytes\n *\n * @param str String to convert\n */\nexport function char2Bytes(str: string) {\n  return Buffer.from(str, 'utf8').toString('hex');\n}\n\n/**\n *\n * @description Convert bytes to a string\n *\n * @param str Bytes to convert\n */\nexport function bytes2Char(hex: string): string {\n  return Buffer.from(hex2buf(hex)).toString('utf8');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}