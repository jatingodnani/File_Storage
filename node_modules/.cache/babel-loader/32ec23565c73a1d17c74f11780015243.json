{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { sign } from '@stablelib/ed25519';\nimport axios from 'axios';\nimport { getHexHash, toHex, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload, secretbox_NONCEBYTES, secretbox_MACBYTES } from '@airgap/beacon-utils';\nimport { MatrixClient } from '../matrix-client/MatrixClient';\nimport { MatrixClientEventType } from '../matrix-client/models/MatrixClientEvent';\nimport { MatrixMessageType } from '../matrix-client/models/MatrixMessage';\nimport { StorageKey, Regions } from '@airgap/beacon-types';\nimport { PeerManager, BEACON_VERSION, getSenderId, Logger, CommunicationClient } from '@airgap/beacon-core';\nimport { ExposedPromise, generateGUID } from '@airgap/beacon-utils';\nimport { hash } from '@stablelib/blake2b';\nimport { encode } from '@stablelib/utf8';\nconst logger = new Logger('P2PCommunicationClient');\nconst REGIONS_AND_SERVERS = {\n  [Regions.EUROPE_WEST]: ['beacon-node-1.diamond.papers.tech', 'beacon-node-1.sky.papers.tech', 'beacon-node-2.sky.papers.tech', 'beacon-node-1.hope.papers.tech', 'beacon-node-1.hope-2.papers.tech', 'beacon-node-1.hope-3.papers.tech', 'beacon-node-1.hope-4.papers.tech', 'beacon-node-1.hope-5.papers.tech']\n};\n/**\r\n * @internalapi\r\n */\nexport class P2PCommunicationClient extends CommunicationClient {\n  constructor(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {\n    super(keyPair);\n    this.name = name;\n    this.replicationCount = replicationCount;\n    this.storage = storage;\n    this.iconUrl = iconUrl;\n    this.appUrl = appUrl;\n    this.client = new ExposedPromise();\n    this.activeListeners = new Map();\n    this.ignoredRooms = [];\n    this.loginCounter = 0;\n    logger.log('constructor', 'P2PCommunicationClient created');\n    this.ENABLED_RELAY_SERVERS = REGIONS_AND_SERVERS;\n    if (matrixNodes) {\n      this.ENABLED_RELAY_SERVERS = Object.assign(Object.assign({}, REGIONS_AND_SERVERS), matrixNodes);\n    }\n  }\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = {\n        id: yield generateGUID(),\n        type: 'p2p-pairing-request',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey(),\n        relayServer: (yield this.getRelayServer()).server\n      };\n      if (this.iconUrl) {\n        info.icon = this.iconUrl;\n      }\n      if (this.appUrl) {\n        info.appUrl = this.appUrl;\n      }\n      return info;\n    });\n  }\n  getPairingResponseInfo(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = {\n        id: request.id,\n        type: 'p2p-pairing-response',\n        name: this.name,\n        version: request.version,\n        publicKey: yield this.getPublicKey(),\n        relayServer: (yield this.getRelayServer()).server\n      };\n      if (this.iconUrl) {\n        info.icon = this.iconUrl;\n      }\n      if (this.appUrl) {\n        info.appUrl = this.appUrl;\n      }\n      return info;\n    });\n  }\n  findBestRegion() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.selectedRegion) {\n        return this.selectedRegion;\n      }\n      const keys = Object.keys(this.ENABLED_RELAY_SERVERS);\n      const allPromises = [];\n      keys.forEach(key => {\n        var _a;\n        const nodes = (_a = this.ENABLED_RELAY_SERVERS[key]) !== null && _a !== void 0 ? _a : [];\n        const index = Math.floor(Math.random() * nodes.length);\n        allPromises.push(this.getBeaconInfo(nodes[index]).then(res => ({\n          region: key,\n          server: nodes[index],\n          response: res\n        })).catch(err => new Promise((_resolve, reject) => {\n          // This workaround is done because Promise.race stops at the first failure, but we need the first success.\n          // TODO: If all promises have been rejected, let's not wait 2000 and abort earlier.\n          setTimeout(() => reject(err), 2000);\n        })));\n      });\n      const region = yield Promise.race(allPromises);\n      this.selectedRegion = region.region;\n      return region.region;\n      // Select random server from each region.\n      // Start request to random server from each region\n      // Fastest response wins, region is selected\n    });\n  }\n\n  getRelayServer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.relayServer) {\n        const relayServer = yield this.relayServer.promise;\n        // We make sure the locally cached timestamp is not older than 1 minute, if it is, we refresh it\n        if (Date.now() - relayServer.localTimestamp < 60 * 1000) {\n          return {\n            server: relayServer.server,\n            timestamp: relayServer.timestamp\n          };\n        }\n        const info = yield this.getBeaconInfo(relayServer.server);\n        this.relayServer.resolve({\n          server: relayServer.server,\n          timestamp: info.timestamp,\n          localTimestamp: new Date().getTime()\n        });\n        return {\n          server: relayServer.server,\n          timestamp: info.timestamp\n        };\n      } else {\n        this.relayServer = new ExposedPromise();\n      }\n      const node = yield this.storage.get(StorageKey.MATRIX_SELECTED_NODE);\n      if (node && node.length > 0) {\n        const info = yield this.getBeaconInfo(node);\n        this.relayServer.resolve({\n          server: node,\n          timestamp: info.timestamp,\n          localTimestamp: new Date().getTime()\n        });\n        return {\n          server: node,\n          timestamp: info.timestamp\n        };\n      }\n      const region = yield this.findBestRegion();\n      const regionNodes = this.ENABLED_RELAY_SERVERS[region];\n      if (!regionNodes) {\n        throw new Error(`No servers found for region ${region}`);\n      }\n      const nodes = [...regionNodes];\n      while (nodes.length > 0) {\n        const index = Math.floor(Math.random() * nodes.length);\n        const server = nodes[index];\n        try {\n          const response = yield this.getBeaconInfo(server);\n          this.storage.set(StorageKey.MATRIX_SELECTED_NODE, server).catch(error => logger.log(error));\n          this.relayServer.resolve({\n            server,\n            timestamp: response.timestamp,\n            localTimestamp: new Date().getTime()\n          });\n          return {\n            server,\n            timestamp: response.timestamp\n          };\n        } catch (relayError) {\n          logger.log(`Ignoring server \"${server}\", trying another one...`);\n          nodes.splice(index, 1);\n        }\n      }\n      this.relayServer.reject(`No matrix server reachable!`);\n      throw new Error(`No matrix server reachable!`);\n    });\n  }\n  getBeaconInfo(server) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return axios.get(`https://${server}/_synapse/client/beacon/info`).then(res => ({\n        region: res.data.region,\n        known_servers: res.data.known_servers,\n        timestamp: Math.floor(res.data.timestamp)\n      }));\n    });\n  }\n  tryJoinRooms(roomId) {\n    let retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield (yield this.client.promise).joinRooms(roomId);\n      } catch (error) {\n        if (retry <= 10 && error.errcode === 'M_FORBIDDEN') {\n          // If we join the room too fast after receiving the invite, the server can accidentally reject our join. This seems to be a problem only when using a federated multi-node setup. Usually waiting for a couple milliseconds solves the issue, but to handle lag, we will keep retrying for 2 seconds.\n          logger.log(`Retrying to join...`, error);\n          setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            yield this.tryJoinRooms(roomId, retry + 1);\n          }), 200);\n        } else {\n          logger.log(`Failed to join after ${retry} tries.`, error);\n        }\n      }\n    });\n  }\n  start() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('start', 'starting client');\n      logger.log('start', `connecting to server`);\n      const relayServer = yield this.getRelayServer();\n      const client = MatrixClient.create({\n        baseUrl: `https://${relayServer.server}`,\n        storage: this.storage\n      });\n      this.initialListener = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {\n          if (this.initialEvent.timestamp < event.timestamp) {\n            this.initialEvent = event;\n          }\n        } else {\n          this.initialEvent = event;\n        }\n      });\n      client.subscribe(MatrixClientEventType.MESSAGE, this.initialListener);\n      client.subscribe(MatrixClientEventType.INVITE, event => __awaiter(this, void 0, void 0, function* () {\n        let member;\n        if (event.content.members.length === 1) {\n          // If there is only one member we know it's a new room\n          // TODO: Use the \"sender\" of the event instead\n          member = event.content.members[0];\n        }\n        yield this.tryJoinRooms(event.content.roomId);\n        if (member) {\n          yield this.updateRelayServer(member);\n          yield this.updatePeerRoom(member, event.content.roomId);\n        }\n      }));\n      if (!relayServer.timestamp) {\n        throw new Error('No timestamp received from relay server');\n      }\n      const time = Math.floor(relayServer.timestamp);\n      const loginString = `login:${Math.floor(time / (5 * 60))}`;\n      logger.log('start', `login ${loginString}, ${yield this.getPublicKeyHash()} on ${relayServer.server}`);\n      const loginRawDigest = hash(encode(loginString), 32);\n      const secretKey = (_a = this.keyPair.secretKey) !== null && _a !== void 0 ? _a : this.keyPair.privateKey;\n      const rawSignature = sign(secretKey, loginRawDigest);\n      try {\n        yield client.start({\n          id: yield this.getPublicKeyHash(),\n          password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,\n          deviceId: toHex(this.keyPair.publicKey)\n        });\n      } catch (error) {\n        logger.error('start', 'Could not log in, retrying');\n        yield this.reset(); // If we can't log in, let's reset\n        if (!this.selectedRegion) {\n          throw new Error('No region selected.');\n        }\n        if (this.loginCounter <= ((_b = this.ENABLED_RELAY_SERVERS[this.selectedRegion]) !== null && _b !== void 0 ? _b : []).length) {\n          this.loginCounter++;\n          this.start();\n          return;\n        } else {\n          logger.error('start', 'Tried to log in to every known beacon node, but no login was successful.');\n          throw new Error('Could not connect to any beacon nodes. Try again later.');\n        }\n      }\n      logger.log('start', 'login successful, client is ready');\n      this.client.resolve(client);\n    });\n  }\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('stop', 'stopping client');\n      if (this.client.isResolved()) {\n        yield (yield this.client.promise).stop().catch(error => logger.error(error));\n      }\n      yield this.reset();\n    });\n  }\n  reset() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('reset', 'resetting connection');\n      yield this.storage.delete(StorageKey.MATRIX_PEER_ROOM_IDS).catch(error => logger.log(error));\n      yield this.storage.delete(StorageKey.MATRIX_PRESERVED_STATE).catch(error => logger.log(error));\n      yield this.storage.delete(StorageKey.MATRIX_SELECTED_NODE).catch(error => logger.log(error));\n      // Instead of resetting everything, maybe we should make sure a new instance is created?\n      this.relayServer = undefined;\n      this.client = new ExposedPromise();\n      this.initialEvent = undefined;\n      this.initialListener = undefined;\n    });\n  }\n  listenForEncryptedMessage(senderPublicKey, messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.activeListeners.has(senderPublicKey)) {\n        return;\n      }\n      logger.log('listenForEncryptedMessage', `start listening for encrypted messages from publicKey ${senderPublicKey}`);\n      const sharedKey = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair);\n      const callbackFunction = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {\n          let payload;\n          yield this.updateRelayServer(event.content.message.sender);\n          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n          try {\n            payload = Buffer.from(event.content.message.content, 'hex');\n            // content can be non-hex if it's a connection open request\n          } catch (_a) {\n            /* */\n          }\n          if (payload && payload.length >= secretbox_NONCEBYTES + secretbox_MACBYTES) {\n            try {\n              const decryptedMessage = yield decryptCryptoboxPayload(payload, sharedKey.receive);\n              logger.log('listenForEncryptedMessage', `received a message from ${senderPublicKey}`, decryptedMessage);\n              // logger.log(\n              //   'listenForEncryptedMessage',\n              //   'encrypted message received',\n              //   decryptedMessage,\n              //   await new Serializer().deserialize(decryptedMessage)\n              // )\n              // console.log('calculated sender ID', await getSenderId(senderPublicKey))\n              // TODO: Add check for correct decryption key / sender ID\n              messageCallback(decryptedMessage);\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      });\n      this.activeListeners.set(senderPublicKey, callbackFunction);\n      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, callbackFunction);\n      const lastEvent = this.initialEvent;\n      if (lastEvent && lastEvent.timestamp && new Date().getTime() - lastEvent.timestamp < 5 * 60 * 1000) {\n        logger.log('listenForEncryptedMessage', 'Handling previous event');\n        yield callbackFunction(lastEvent);\n      } else {\n        logger.log('listenForEncryptedMessage', 'No previous event found');\n      }\n      const initialListener = this.initialListener;\n      if (initialListener) {\n        ;\n        (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, initialListener);\n      }\n      this.initialListener = undefined;\n      this.initialEvent = undefined;\n    });\n  }\n  unsubscribeFromEncryptedMessage(senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const listener = this.activeListeners.get(senderPublicKey);\n      if (!listener) {\n        return;\n      }\n      ;\n      (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, listener);\n      this.activeListeners.delete(senderPublicKey);\n    });\n  }\n  unsubscribeFromEncryptedMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      ;\n      (yield this.client.promise).unsubscribeAll(MatrixClientEventType.MESSAGE);\n      this.activeListeners.clear();\n    });\n  }\n  sendMessage(message, peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const sharedKey = yield this.createCryptoBoxClient(peer.publicKey, this.keyPair);\n      const recipientHash = yield getHexHash(Buffer.from(peer.publicKey, 'hex'));\n      const recipient = recipientString(recipientHash, peer.relayServer);\n      const roomId = yield this.getRelevantRoom(recipient);\n      // Before we send the message, we have to wait for the join to be accepted.\n      yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n      const encryptedMessage = yield encryptCryptoboxPayload(message, sharedKey.send);\n      logger.log('sendMessage', 'sending encrypted message', peer.publicKey, roomId, message);\n      (yield this.client.promise).sendTextMessage(roomId, encryptedMessage).catch(error => __awaiter(this, void 0, void 0, function* () {\n        if (error.errcode === 'M_FORBIDDEN') {\n          // Room doesn't exist\n          logger.log(`sendMessage`, `M_FORBIDDEN`, roomId, error);\n          yield this.deleteRoomIdFromRooms(roomId);\n          const newRoomId = yield this.getRelevantRoom(recipient);\n          logger.log(`sendMessage`, `Old room deleted, new room created`, newRoomId);\n          (yield this.client.promise).sendTextMessage(newRoomId, encryptedMessage).catch(error2 => __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendMessage`, `inner error`, newRoomId, error2);\n          }));\n        } else {\n          logger.log(`sendMessage`, `unexpected error`, error);\n        }\n      }));\n    });\n  }\n  updatePeerRoom(sender, roomId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`updatePeerRoom`, sender, roomId);\n      // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n      const split = sender.split(':');\n      if (split.length < 2 || !split[0].startsWith('@')) {\n        throw new Error('Invalid sender');\n      }\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      const room = roomIds[sender];\n      if (room === roomId) {\n        logger.debug(`updatePeerRoom`, `rooms are the same, not updating`);\n      }\n      logger.debug(`updatePeerRoom`, `current room`, room, 'new room', roomId);\n      if (room && room[1]) {\n        // If we have a room already, let's ignore it. We need to do this, otherwise it will be loaded from the matrix cache.\n        logger.log(`updatePeerRoom`, `adding room \"${room[1]}\" to ignored array`);\n        this.ignoredRooms.push(room[1]);\n      }\n      roomIds[sender] = roomId;\n      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n      // TODO: We also need to delete the room from the sync state\n      // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n    });\n  }\n\n  deleteRoomIdFromRooms(roomId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      const newRoomIds = Object.entries(roomIds).filter(entry => entry[1] !== roomId).reduce((pv, cv) => Object.assign(Object.assign({}, pv), {\n        [cv[0]]: cv[1]\n      }), {});\n      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds);\n      // TODO: We also need to delete the room from the sync state\n      // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n      this.ignoredRooms.push(roomId);\n    });\n  }\n  listenForChannelOpening(messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug(`listenForChannelOpening`);\n      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {\n          logger.log(`listenForChannelOpening`, `channel opening received, trying to decrypt`, JSON.stringify(event));\n          yield this.updateRelayServer(event.content.message.sender);\n          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n          const splits = event.content.message.content.split(':');\n          const payload = Buffer.from(splits[splits.length - 1], 'hex');\n          if (payload.length >= secretbox_NONCEBYTES + secretbox_MACBYTES) {\n            try {\n              const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.secretKey));\n              logger.log(`listenForChannelOpening`, `channel opening received and decrypted`, JSON.stringify(pairingResponse));\n              messageCallback(Object.assign(Object.assign({}, pairingResponse), {\n                senderId: yield getSenderId(pairingResponse.publicKey)\n              }));\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      }));\n    });\n  }\n  waitForJoin(roomId) {\n    let retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return __awaiter(this, void 0, void 0, function* () {\n      // Rooms are updated as new events come in. `client.getRoomById` only accesses memory, it does not do any network requests.\n      // TODO: Improve to listen to \"JOIN\" event\n      const room = yield (yield this.client.promise).getRoomById(roomId);\n      logger.log(`waitForJoin`, `Currently ${room.members.length} members, we need at least 2`);\n      if (room.members.length >= 2 || room.members.length === 0) {\n        // 0 means it's an unknown room, we don't need to wait\n        return;\n      } else {\n        if (retry <= 200) {\n          // On mobile, due to app switching, we potentially have to wait for a long time\n          logger.log(`Waiting for join... Try: ${retry}`);\n          return new Promise(resolve => {\n            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n              resolve(this.waitForJoin(roomId, retry + 1));\n            }), 100 * (retry > 50 ? 10 : 1)); // After the initial 5 seconds, retry only once per second\n          });\n        } else {\n          throw new Error(`No one joined after ${retry} tries.`);\n        }\n      }\n    });\n  }\n  sendPairingResponse(pairingRequest) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`sendPairingResponse`);\n      const recipientHash = yield getHexHash(Buffer.from(pairingRequest.publicKey, 'hex'));\n      const recipient = recipientString(recipientHash, pairingRequest.relayServer);\n      // We force room creation here because if we \"re-pair\", we need to make sure that we don't send it to an old room.\n      const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n      logger.debug(`sendPairingResponse`, `Connecting to room \"${roomId}\"`);\n      yield this.updatePeerRoom(recipient, roomId);\n      // Before we send the message, we have to wait for the join to be accepted.\n      yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n      logger.debug(`sendPairingResponse`, `Successfully joined room.`);\n      // TODO: remove v1 backwards-compatibility\n      const message = typeof pairingRequest.version === 'undefined' ? yield this.getPublicKey() // v1\n      : JSON.stringify(yield this.getPairingResponseInfo(pairingRequest)); // v2\n      logger.debug(`sendPairingResponse`, `Sending pairing response`, message);\n      const encryptedMessage = yield this.encryptMessageAsymmetric(pairingRequest.publicKey, message);\n      const msg = ['@channel-open', recipient, encryptedMessage].join(':');\n      (yield this.client.promise).sendTextMessage(roomId, msg).catch(error => __awaiter(this, void 0, void 0, function* () {\n        if (error.errcode === 'M_FORBIDDEN') {\n          // Room doesn't exist\n          logger.log(`sendPairingResponse`, `M_FORBIDDEN`, roomId, error);\n          yield this.deleteRoomIdFromRooms(roomId);\n          const newRoomId = yield this.getRelevantRoom(recipient);\n          logger.log(`sendPairingResponse`, `Old room deleted, new room created`, newRoomId);\n          (yield this.client.promise).sendTextMessage(newRoomId, msg).catch(error2 => __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendPairingResponse`, `inner error`, newRoomId, error2);\n          }));\n        } else {\n          logger.log(`sendPairingResponse`, `unexpected error`, error);\n        }\n      }));\n    });\n  }\n  isTextMessage(content) {\n    return content.message.type === MatrixMessageType.TEXT;\n  }\n  updateRelayServer(sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`updateRelayServer`, sender);\n      // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n      const split = sender.split(':');\n      if (split.length < 2 || !split[0].startsWith('@')) {\n        throw new Error('Invalid sender');\n      }\n      const senderHash = split.shift();\n      const relayServer = split.join(':');\n      const manager = localStorage.getItem('beacon:communication-peers-dapp') ? new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP) : new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_WALLET);\n      const peers = yield manager.getPeers();\n      const promiseArray = peers.map(peer => __awaiter(this, void 0, void 0, function* () {\n        const hash = `@${yield getHexHash(Buffer.from(peer.publicKey, 'hex'))}`;\n        if (hash === senderHash) {\n          if (peer.relayServer !== relayServer) {\n            peer.relayServer = relayServer;\n            yield manager.addPeer(peer);\n          }\n        }\n      }));\n      yield Promise.all(promiseArray);\n    });\n  }\n  isChannelOpenMessage(content) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);\n    });\n  }\n  isSender(event, senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);\n    });\n  }\n  getRelevantRoom(recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      let roomId = roomIds[recipient];\n      if (!roomId) {\n        logger.log(`getRelevantRoom`, `No room found for peer ${recipient}, checking joined ones.`);\n        const room = yield this.getRelevantJoinedRoom(recipient);\n        roomId = room.id;\n        roomIds[recipient] = room.id;\n        yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n      }\n      logger.log(`getRelevantRoom`, `Using room ${roomId}`);\n      return roomId;\n    });\n  }\n  getRelevantJoinedRoom(recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const joinedRooms = yield (yield this.client.promise).joinedRooms;\n      logger.log('checking joined rooms', joinedRooms, recipient);\n      const relevantRooms = joinedRooms.filter(roomElement => !this.ignoredRooms.some(id => roomElement.id === id)).filter(roomElement => roomElement.members.some(member => member === recipient));\n      let room;\n      // We always create a new room if one has been ignored. This is because if we ignore one, we know the server state changed.\n      // So we cannot trust the current sync state. This can be removed once we have a method to properly clear and refresh the sync state.\n      if (relevantRooms.length === 0 || this.ignoredRooms.length > 0) {\n        logger.log(`getRelevantJoinedRoom`, `no relevant rooms found, creating new one`);\n        const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n        room = yield (yield this.client.promise).getRoomById(roomId);\n        logger.log(`getRelevantJoinedRoom`, `waiting for other party to join room: ${room.id}`);\n        yield this.waitForJoin(roomId);\n        logger.log(`getRelevantJoinedRoom`, `new room created and peer invited: ${room.id}`);\n      } else {\n        room = relevantRooms[0];\n        logger.log(`getRelevantJoinedRoom`, `channel already open, reusing room ${room.id}`);\n      }\n      return room;\n    });\n  }\n}","map":{"version":3,"names":["sign","axios","getHexHash","toHex","recipientString","openCryptobox","encryptCryptoboxPayload","decryptCryptoboxPayload","secretbox_NONCEBYTES","secretbox_MACBYTES","MatrixClient","MatrixClientEventType","MatrixMessageType","StorageKey","Regions","PeerManager","BEACON_VERSION","getSenderId","Logger","CommunicationClient","ExposedPromise","generateGUID","hash","encode","logger","REGIONS_AND_SERVERS","EUROPE_WEST","P2PCommunicationClient","constructor","name","keyPair","replicationCount","storage","matrixNodes","iconUrl","appUrl","client","activeListeners","Map","ignoredRooms","loginCounter","log","ENABLED_RELAY_SERVERS","Object","assign","getPairingRequestInfo","info","id","type","version","publicKey","getPublicKey","relayServer","getRelayServer","server","icon","getPairingResponseInfo","request","findBestRegion","selectedRegion","keys","allPromises","forEach","key","nodes","_a","index","Math","floor","random","length","push","getBeaconInfo","then","res","region","response","catch","err","Promise","_resolve","reject","setTimeout","race","promise","Date","now","localTimestamp","timestamp","resolve","getTime","node","get","MATRIX_SELECTED_NODE","regionNodes","Error","set","error","relayError","splice","data","known_servers","tryJoinRooms","roomId","retry","arguments","undefined","joinRooms","errcode","__awaiter","start","create","baseUrl","initialListener","event","initialEvent","subscribe","MESSAGE","INVITE","member","content","members","updateRelayServer","updatePeerRoom","time","loginString","getPublicKeyHash","loginRawDigest","secretKey","privateKey","rawSignature","password","deviceId","reset","_b","stop","isResolved","delete","MATRIX_PEER_ROOM_IDS","MATRIX_PRESERVED_STATE","listenForEncryptedMessage","senderPublicKey","messageCallback","has","sharedKey","createCryptoBoxServer","callbackFunction","isTextMessage","isSender","payload","message","sender","Buffer","from","decryptedMessage","receive","decryptionError","lastEvent","unsubscribe","unsubscribeFromEncryptedMessage","listener","unsubscribeFromEncryptedMessages","unsubscribeAll","clear","sendMessage","peer","createCryptoBoxClient","recipientHash","recipient","getRelevantRoom","waitForJoin","encryptedMessage","send","sendTextMessage","deleteRoomIdFromRooms","newRoomId","error2","split","startsWith","roomIds","room","debug","newRoomIds","entries","filter","entry","reduce","pv","cv","listenForChannelOpening","isChannelOpenMessage","JSON","stringify","splits","pairingResponse","parse","senderId","getRoomById","sendPairingResponse","pairingRequest","createTrustedPrivateRoom","encryptMessageAsymmetric","msg","join","TEXT","senderHash","shift","manager","localStorage","getItem","TRANSPORT_P2P_PEERS_DAPP","TRANSPORT_P2P_PEERS_WALLET","peers","getPeers","promiseArray","map","addPeer","all","getRelevantJoinedRoom","joinedRooms","relevantRooms","roomElement","some"],"sources":["../../../src/communication-client/P2PCommunicationClient.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module"}