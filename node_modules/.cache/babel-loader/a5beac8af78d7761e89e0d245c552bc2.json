{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { StorageKey, TransportStatus } from '@airgap/beacon-types';\nimport { Logger } from '@airgap/beacon-core';\nimport { P2PTransport } from '@airgap/beacon-transport-matrix';\nconst logger = new Logger('DappP2PTransport');\n/**\n * @internalapi\n *\n *\n */\nexport class DappP2PTransport extends P2PTransport {\n  constructor(name, keyPair, storage, matrixNodes, iconUrl, appUrl) {\n    super(name, keyPair, storage, matrixNodes, StorageKey.TRANSPORT_P2P_PEERS_DAPP, iconUrl, appUrl);\n  }\n  startOpenChannelListener() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.client.listenForChannelOpening(peer => __awaiter(this, void 0, void 0, function* () {\n        logger.log('listenForNewPeer', `new publicKey`, peer.publicKey);\n        yield this.addPeer(peer);\n        this._isConnected = TransportStatus.CONNECTED;\n        if (this.newPeerListener) {\n          this.newPeerListener(peer);\n          this.newPeerListener = undefined; // TODO: Remove this once we use the id\n        }\n      }));\n    });\n  }\n\n  listenForNewPeer(newPeerListener) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('listenForNewPeer');\n      this.newPeerListener = newPeerListener;\n    });\n  }\n  stopListeningForNewPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('stopListeningForNewPeers');\n      this.newPeerListener = undefined;\n    });\n  }\n}","map":{"version":3,"names":["StorageKey","TransportStatus","Logger","P2PTransport","logger","DappP2PTransport","constructor","name","keyPair","storage","matrixNodes","iconUrl","appUrl","TRANSPORT_P2P_PEERS_DAPP","startOpenChannelListener","client","listenForChannelOpening","peer","__awaiter","log","publicKey","addPeer","_isConnected","CONNECTED","newPeerListener","undefined","listenForNewPeer","stopListeningForNewPeers"],"sources":["../../../src/transports/DappP2PTransport.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAEEA,UAAU,EACVC,eAAe,QAGV,sBAAsB;AAC7B,SAASC,MAAM,QAAQ,qBAAqB;AAC5C,SAASC,YAAY,QAAQ,iCAAiC;AAG9D,MAAMC,MAAM,GAAG,IAAIF,MAAM,CAAC,kBAAkB,CAAC;AAE7C;;;;;AAKA,OAAM,MAAOG,gBAAiB,SAAQF,YAGrC;EACCG,YACEC,IAAY,EACZC,OAAgB,EAChBC,OAAgB,EAChBC,WAA8B,EAC9BC,OAAgB,EAChBC,MAAe;IAEf,KAAK,CAACL,IAAI,EAAEC,OAAO,EAAEC,OAAO,EAAEC,WAAW,EAAEV,UAAU,CAACa,wBAAwB,EAAEF,OAAO,EAAEC,MAAM,CAAC;EAClG;EAEaE,wBAAwBA,CAAA;;MACnC,OAAO,IAAI,CAACC,MAAM,CAACC,uBAAuB,CAAQC,IAAI,IAAIC,SAAA;QACxDd,MAAM,CAACe,GAAG,CAAC,kBAAkB,EAAE,eAAe,EAAEF,IAAI,CAACG,SAAS,CAAC;QAE/D,MAAM,IAAI,CAACC,OAAO,CAACJ,IAAI,CAAC;QAExB,IAAI,CAACK,YAAY,GAAGrB,eAAe,CAACsB,SAAS;QAE7C,IAAI,IAAI,CAACC,eAAe,EAAE;UACxB,IAAI,CAACA,eAAe,CAACP,IAAI,CAAC;UAC1B,IAAI,CAACO,eAAe,GAAGC,SAAS,EAAC;;MAErC,CAAC,EAAC;IACJ,CAAC;;;EAEYC,gBAAgBA,CAC3BF,eAA2D;;MAE3DpB,MAAM,CAACe,GAAG,CAAC,kBAAkB,CAAC;MAC9B,IAAI,CAACK,eAAe,GAAGA,eAAe;IACxC,CAAC;;EAEYG,wBAAwBA,CAAA;;MACnCvB,MAAM,CAACe,GAAG,CAAC,0BAA0B,CAAC;MACtC,IAAI,CAACK,eAAe,GAAGC,SAAS;IAClC,CAAC"},"metadata":{},"sourceType":"module"}