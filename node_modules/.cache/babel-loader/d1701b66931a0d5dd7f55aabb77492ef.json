{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { Logger } from '../utils/Logger';\nimport { TransportType, TransportStatus } from '@airgap/beacon-types';\nconst logger = new Logger('Transport');\n/**\r\n * @internalapi\r\n *\r\n *\r\n */\nexport class Transport {\n  constructor(name, client, peerManager) {\n    /**\r\n     * The type of the transport\r\n     */\n    this.type = TransportType.POST_MESSAGE;\n    /**\r\n     * The status of the transport\r\n     */\n    this._isConnected = TransportStatus.NOT_CONNECTED;\n    /**\r\n     * The listeners that will be notified when new messages are coming in\r\n     */\n    this.listeners = [];\n    this.name = name;\n    this.client = client;\n    this.peerManager = peerManager;\n  }\n  /**\r\n   * Return the status of the connection\r\n   */\n  get connectionStatus() {\n    return this._isConnected;\n  }\n  /**\r\n   * Returns a promise that resolves to true if the transport is available, false if it is not\r\n   */\n  static isAvailable() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.resolve(false);\n    });\n  }\n  /**\r\n   * Connect the transport\r\n   */\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('connect');\n      this._isConnected = TransportStatus.CONNECTED;\n      return;\n    });\n  }\n  /**\r\n   * Disconnect the transport\r\n   */\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('disconnect');\n      this._isConnected = TransportStatus.NOT_CONNECTED;\n      return;\n    });\n  }\n  /**\r\n   * Send a message through the transport\r\n   *\r\n   * @param message The message to send\r\n   * @param recipient The recipient of the message\r\n   */\n  send(message, peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (peer) {\n        return this.client.sendMessage(message, peer);\n      } else {\n        const knownPeers = yield this.getPeers();\n        // A broadcast request has to be sent everywhere.\n        const promises = knownPeers.map(peerEl => this.client.sendMessage(message, peerEl));\n        return (yield Promise.all(promises))[0];\n      }\n    });\n  }\n  /**\r\n   * Add a listener to be called when a new message is received\r\n   *\r\n   * @param listener The listener that will be registered\r\n   */\n  addListener(listener) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('addListener');\n      this.listeners.push(listener);\n      return;\n    });\n  }\n  /**\r\n   * Remove a listener\r\n   *\r\n   * @param listener\r\n   */\n  removeListener(listener) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removeListener');\n      this.listeners = this.listeners.filter(element => element !== listener);\n      return;\n    });\n  }\n  getPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.peerManager.getPeers(); // TODO: Fix type\n    });\n  }\n\n  addPeer(newPeer) {\n    let _sendPairingResponse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('addPeer', 'adding peer', newPeer);\n      yield this.peerManager.addPeer(newPeer); // TODO: Fix type\n      yield this.listen(newPeer.publicKey);\n    });\n  }\n  removePeer(peerToBeRemoved) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removePeer', 'removing peer', peerToBeRemoved);\n      yield this.peerManager.removePeer(peerToBeRemoved.publicKey);\n      if (this.client) {\n        yield this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);\n      }\n    });\n  }\n  removeAllPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removeAllPeers');\n      yield this.peerManager.removeAllPeers();\n      if (this.client) {\n        yield this.client.unsubscribeFromEncryptedMessages();\n      }\n    });\n  }\n  /**\r\n   * Notify the listeners when a new message comes in\r\n   *\r\n   * @param message Message\r\n   * @param connectionInfo Context info about the connection\r\n   */\n  notifyListeners(message, connectionInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.listeners.length === 0) {\n        logger.warn('notifyListeners', '0 listeners notified!', this);\n      } else {\n        logger.log('notifyListeners', `Notifying ${this.listeners.length} listeners`, this);\n      }\n      this.listeners.forEach(listener => {\n        listener(message, connectionInfo);\n      });\n      return;\n    });\n  }\n}","map":{"version":3,"names":["Logger","TransportType","TransportStatus","logger","Transport","constructor","name","client","peerManager","type","POST_MESSAGE","_isConnected","NOT_CONNECTED","listeners","connectionStatus","isAvailable","Promise","resolve","connect","log","CONNECTED","disconnect","send","message","peer","sendMessage","knownPeers","getPeers","promises","map","peerEl","all","addListener","listener","debug","push","removeListener","filter","element","addPeer","newPeer","_sendPairingResponse","arguments","length","undefined","listen","publicKey","removePeer","peerToBeRemoved","unsubscribeFromEncryptedMessage","removeAllPeers","unsubscribeFromEncryptedMessages","notifyListeners","connectionInfo","warn","forEach"],"sources":["../../../src/transports/Transport.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module"}