{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/**\n * A service to help with matrix event management\n */\nexport class MatrixEventService {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n    this.cachedPromises = new Map();\n  }\n  /**\n   * Get the latest state from the matrix node\n   *\n   * @param accessToken\n   * @param options\n   */\n  sync(accessToken, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.withCache('sync', () => this.httpClient.get('/sync', {\n        timeout: options ? options.pollingTimeout : undefined,\n        since: options ? options.syncToken : undefined\n      }, {\n        accessToken\n      }));\n    });\n  }\n  /**\n   * Send a message to a room\n   *\n   * @param accessToken\n   * @param room\n   * @param content\n   * @param txnId\n   */\n  sendMessage(accessToken, roomId, content, txnId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => this.scheduleEvent({\n        accessToken,\n        roomId,\n        type: 'm.room.message',\n        content,\n        txnId,\n        onSuccess: resolve,\n        onError: reject\n      }));\n    });\n  }\n  /**\n   * Schedules an event to be sent to the node\n   *\n   * @param event\n   */\n  scheduleEvent(event) {\n    // TODO: actual scheduling\n    this.sendEvent(event);\n  }\n  /**\n   * Send an event to the matrix node\n   *\n   * @param scheduledEvent\n   */\n  sendEvent(scheduledEvent) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        roomId,\n        type,\n        txnId,\n        content,\n        accessToken\n      } = scheduledEvent;\n      try {\n        const response = yield this.httpClient.put(`/rooms/${encodeURIComponent(roomId)}/send/${type}/${encodeURIComponent(txnId)}`, content, {\n          accessToken\n        });\n        scheduledEvent.onSuccess(response);\n      } catch (error) {\n        scheduledEvent.onError(error);\n      }\n    });\n  }\n  /**\n   * Check the cache when interacting with the Matrix node, if there is an already ongoing call for the specified key, return its promise instead of duplicating the call.\n   *\n   * @param key\n   * @param promiseProvider\n   */\n  withCache(key, promiseProvider) {\n    let promise = this.cachedPromises.get(key);\n    if (!promise) {\n      promise = promiseProvider().finally(() => {\n        this.cachedPromises.delete(key);\n      });\n      this.cachedPromises.set(key, promise);\n    }\n    return promise;\n  }\n}","map":{"version":3,"names":["MatrixEventService","constructor","httpClient","cachedPromises","Map","sync","accessToken","options","withCache","get","timeout","pollingTimeout","undefined","since","syncToken","sendMessage","roomId","content","txnId","Promise","resolve","reject","scheduleEvent","type","onSuccess","onError","event","sendEvent","scheduledEvent","response","put","encodeURIComponent","error","key","promiseProvider","promise","finally","delete","set"],"sources":["../../../../src/matrix-client/services/MatrixEventService.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;AAGA,OAAM,MAAOA,kBAAkB;EAG7BC,YAA6BC,UAA4B;IAA5B,KAAAA,UAAU,GAAVA,UAAU;IAFtB,KAAAC,cAAc,GAAiC,IAAIC,GAAG,EAAE;EAEb;EAE5D;;;;;;EAMaC,IAAIA,CAACC,WAAmB,EAAEC,OAA2B;;MAChE,OAAO,IAAI,CAACC,SAAS,CAAC,MAAM,EAAE,MAC5B,IAAI,CAACN,UAAU,CAACO,GAAG,CACjB,OAAO,EACP;QACEC,OAAO,EAAEH,OAAO,GAAGA,OAAO,CAACI,cAAc,GAAGC,SAAS;QACrDC,KAAK,EAAEN,OAAO,GAAGA,OAAO,CAACO,SAAS,GAAGF;OACtC,EACD;QAAEN;MAAW,CAAE,CAChB,CACF;IACH,CAAC;;EAED;;;;;;;;EAQaS,WAAWA,CACtBT,WAAmB,EACnBU,MAAc,EACdC,OAAuC,EACvCC,KAAa;;MAEb,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KACjC,IAAI,CAACC,aAAa,CAAC;QACjBhB,WAAW;QACXU,MAAM;QACNO,IAAI,EAAE,gBAAgB;QACtBN,OAAO;QACPC,KAAK;QACLM,SAAS,EAAEJ,OAAO;QAClBK,OAAO,EAAEJ;OACV,CAAC,CACH;IACH,CAAC;;EAED;;;;;EAKOC,aAAaA,CAACI,KAAgC;IACnD;IACA,IAAI,CAACC,SAAS,CAACD,KAAK,CAAC;EACvB;EAEA;;;;;EAKaC,SAASA,CAACC,cAAyC;;MAC9D,MAAM;QAAEZ,MAAM;QAAEO,IAAI;QAAEL,KAAK;QAAED,OAAO;QAAEX;MAAW,CAAE,GAAGsB,cAAc;MAEpE,IAAI;QACF,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAAC3B,UAAU,CAAC4B,GAAG,CACxC,UAAUC,kBAAkB,CAACf,MAAM,CAAC,SAASO,IAAI,IAAIQ,kBAAkB,CAACb,KAAK,CAAC,EAAE,EAChFD,OAAO,EACP;UAAEX;QAAW,CAAE,CAChB;QACDsB,cAAc,CAACJ,SAAS,CAACK,QAAQ,CAAC;OACnC,CAAC,OAAOG,KAAK,EAAE;QACdJ,cAAc,CAACH,OAAO,CAACO,KAAK,CAAC;;IAEjC,CAAC;;EAED;;;;;;EAMQxB,SAASA,CAAIyB,GAAc,EAAEC,eAAiC;IACpE,IAAIC,OAAO,GAAG,IAAI,CAAChC,cAAc,CAACM,GAAG,CAACwB,GAAG,CAAC;IAE1C,IAAI,CAACE,OAAO,EAAE;MACZA,OAAO,GAAGD,eAAe,EAAE,CAACE,OAAO,CAAC,MAAK;QACvC,IAAI,CAACjC,cAAc,CAACkC,MAAM,CAACJ,GAAG,CAAC;MACjC,CAAC,CAAC;MACF,IAAI,CAAC9B,cAAc,CAACmC,GAAG,CAACL,GAAG,EAAEE,OAAO,CAAC;;IAGvC,OAAOA,OAAO;EAChB"},"metadata":{},"sourceType":"module"}